<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CUDA学习记录]]></title>
    <url>%2F2024%2F11%2F10%2Fcuda%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[线程模型 条目 最大取值 备注 网格 x 2^31 - 1 网格 y 或者 z 63335 线程块 x 或者 y 1024 线程块 z 64 线程块最大线程数 1024]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轨迹跟踪学习笔记]]></title>
    <url>%2F2024%2F05%2F15%2F%E8%BD%A8%E8%BF%B9%E8%B7%9F%E8%B8%AA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[泰勒展开 一元泰勒展开$$f(x) = f(x_{k}) + (x-x_{k})f’(x_{k})+\frac{1}{2!}(x-x_{k})^{2}f’’(x_{k})+o^n$$ 二元泰勒展开$$\begin{array}{c}f(x, y)=f\left(x_{k}, y_{k}\right)+\left(x-x_{k}\right) f_{x}^{\prime}\left(x_{k}, y_{k}\right)+\left(y-y_{k}\right) f_{y}^{\prime}\left(x_{k}, y_{k}\right) \+\frac{1}{2!}\left(x-x_{k}\right)^{2} f_{x x}^{\prime \prime}\left(x_{k}, y_{k}\right)+\frac{1}{2!}\left(x-x_{k}\right)\left(y-y_{k}\right) f_{x y}^{\prime \prime}\left(x_{k}, y_{k}\right) \+\frac{1}{2!}\left(x-x_{k}\right)\left(y-y_{k}\right) f_{y x}^{\prime \prime}\left(x_{k}, y_{k}\right)+\frac{1}{2!}\left(y-y_{k}\right)^{2} f_{y y}^{\prime \prime}\left(x_{k}, y_{k}\right) \+o^{n}\end{array}$$ 多元泰勒展开$$\begin{array}{c}f\left(x^{1}, x^{2}, \ldots, x^{n}\right)=f\left(x_{k}^{1}, x_{k}^{2}, \ldots, x_{k}^{n}\right)+\sum_{i=1}^{n}\left(x^{i}-x_{k}^{i}\right) f_{x^{i}}^{\prime}\left(x_{k}^{1}, x_{k}^{2}, \ldots, x_{k}^{n}\right) \+\frac{1}{2!} \sum_{i, j=1}^{n}\left(x^{i}-x_{k}^{i}\right)\left(x^{j}-x_{k}^{j}\right) f_{x^i x^j}^{\prime \prime}\left(x_{k}^{1}, x_{k}^{2}, \ldots, x_{k}^{n}\right) \+o^{n}\end{array}$$ 运动学建模 运动学公式$$\begin{array}{c} \\ &amp;f(v, \theta) = \dot{x} = v\cos \theta \\ &amp;g(v, \theta) = \dot{y} = v\sin \theta \\ &amp;\dot{\theta } = \omega\end{array}$$偏导数：$$\begin{array}{c} \\ &amp;f_{v}’(v, \theta) = \cos \theta \\ &amp;f_{\theta }’(v, \theta) = -v\sin \theta \\ &amp;g_{v}’(v, \theta) = \sin \theta \\ &amp;g_{\theta }’(v, \theta) = v\cos \theta \\ &amp;\end{array}$$ 所以： $$\left.\begin{aligned}\dot{x} &amp; \approx v_{k}\cos \theta_{k} + (v - v_{k})\cos \theta_{k} - (\theta - \theta_{k})v_{k}\sin \theta_{k} \\\dot{y} &amp; \approx v_{k}\sin \theta_{k} + (v - v_{k})\sin \theta_{k} + (\theta - \theta_{k})v_{k}\cos \theta_{k}\end{aligned}\right.$$]]></content>
      <categories>
        <category>轨迹跟踪</category>
      </categories>
      <tags>
        <tag>轨迹跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Build the Cross-Compilation Environment]]></title>
    <url>%2F2024%2F03%2F07%2FHow-to-build-cross-compilation-environment%2F</url>
    <content type="text"><![CDATA[BackgroundsIn most cases, we now use QEMU technology to run ARM containers on X86 platforms, employing these containers as cross-compilation tools. However, due to the different instruction set architectures between the host environment and the Docker environment, compilation speeds are slow. To address this issue, we can directly use an ARM cross-compiler toolchain on the X86 host. During the development of large projects, when you need to link a large number of third-party libraries, the compiler will alert you of link errors and other issues. HowMy development environment requires Ubuntu 22.04, so the rootfs I am using is Ubuntu 22.04. If you want to use a different version, you can modify the script according to your own situation. Install the cross-compilation toolchain12sudo apt updatesudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu qemu-user-static Build a cross-compilation environment rootfs123git clone https://github.com/kaylorchen/rk3588_dev_rootfs.gitcd rk3588_dev_rootfsbash ./build-rootfs.sh Compile your code using the cross-compilation environmentFollowing the steps above, a file named “toolchain-aarch64.cmake” will be generated in the current directory. You will need to use it in your CMake project.For example:1234mkdir buildcd buildcmake -DCMAKE_TOOLCHAIN_FILE=/opt/data/orangepi/rk3588_dev_rootfs/toolchain-aarch64.cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..make /opt/data/orangepi/rk3588_dev_rootfs/toolchain-aarch64.cmake is an absolute path Update your rootfsWhen we compile code, sometimes we find that some dependency packages are missing. We need to update our rootfs. edit config.sh, add a new package named “aaa”: 123456#!/bin/bashapt updateapt install -y --no-install-recommends vim libopencv-dev g++ gcc \fakeroot devscripts libspdlog-dev libsystemd-dev libcap-dev liblz4-dev \libgcrypt-dev libzstd-dev debhelper rknpu2-dev librockchip-mpp-dev librga-dev \libstb-dev libturbojpeg0-dev libjpeg-turbo8-dev kaylordut-dev aaa update rootfs 1./update.sh]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Run LLM on RK3588]]></title>
    <url>%2F2024%2F02%2F09%2FRun-Llm-on-RK3588%2F</url>
    <content type="text"><![CDATA[Download and Convert Model download 1234sudo apt install git-lfsgit lfs installgit clone https://huggingface.co/Qwen/Qwen-1_8B-Chat convert Update Rknpu DriverCompile and Run Demo]]></content>
      <categories>
        <category>rk3588</category>
      </categories>
      <tags>
        <tag>rk3588</tag>
        <tag>llm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rk3588's yolov8 model conversion from pt to rknn]]></title>
    <url>%2F2024%2F02%2F09%2Frk3588's-yolov8-model-conversion-from-pt-to-rknn%2F</url>
    <content type="text"><![CDATA[BackgroundYolov8’s original model includes post-processing. Some shapes exceed the matrix calculation limit of 3588, so some cropping of the output layer is required. pt to onnxClone ultralytics_yolov8 repository and pull docker1234docker pull kaylor/rk3588_pt2onnxgit clone https://github.com/airockchip/ultralytics_yolov8.gitcd ultralytics_yolov8git checkout 5b7ddd8f821c8f6edb389aa30cfbc88bd903867b Download the newest model files from Yolov8 github repository.For example, I download the model named yolov8n.pt1wget https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n.pt Edit ./ultralytics/cfg/default.yaml, replace “yolov8m-seg.pt” with “yolov8n.pt”1model: yolov8n.pt # (str, optional) path to model file, i.e. yolov8n.pt, yolov8n.yaml Convert pt to onnx…12345678# run the command in your host docker run -it -v $&#123;PWD&#125;:/root/ws kaylor/rk3588_pt2onnx bash----------------------------------# run commnads in your containercd /root/wsexport PYTHONPATH=./ python ./ultralytics/engine/exporter.pyexit onnx to rknn Clone rk3588-convert-to-rknn repository and pull docker 123456cd ../docker pull kaylor/rk3588_onnx2rknn # for yolov8 docker pull kaylor/rk3588_onnx2rknn:beta # for yolov10git clone https://github.com/kaylorchen/rk3588-convert-to-rknn.gitcp ultralytics_yolov8/yolov8n.onnx rk3588-convert-to-rknncd rk3588-convert-to-rknn Convert onnx to rknn123456789# run the command in your host docker run -it -v $&#123;PWD&#125;:/root/ws kaylor/rk3588_onnx2rknn bash # for yolov8docker run -it -v $&#123;PWD&#125;:/root/ws kaylor/rk3588_onnx2rknn:beta bash # for yolov10docker run -it -v $&#123;PWD&#125;:/root/ws kaylor/rk3588_onnx2rknn:2.3.0 bash # for all the yolos----------------------------------# run commnads in your containercd /root/wspython convert.py yolov8n.onnx rk3588 i8 yolov8n.rknnexit Enjoy ~~]]></content>
      <categories>
        <category>rk3588</category>
      </categories>
      <tags>
        <tag>rk3588</tag>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aptly和GPG使用笔记]]></title>
    <url>%2F2023%2F09%2F10%2Faptly%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[GPG生成GPG密钥对不要使用sudo，否则还有权限问题1gpg --full-generate-key 导出私钥和公钥12gpg --export-secret-keys --armor your@email.com &gt; your.gpggpg --export --armor your@email.com &gt; your-pubkey.gpg 列出gpg keys1gpg --list-keys 将公钥提交到公共服务器1gpg --keyserver keyserver.ubuntu.com --send-key 56779B056333DC6B2EC50D0E7C2253769D312CAD 导入公钥私钥1gpg --import public-file.key / private-file.key aptly配置建立一个repo1aptly repo create -distribution=&quot;focal&quot; -component=&quot;main&quot; -comment=&quot;kaylor ros2 humble repository&quot; repository_name distribution 是list中url之后的第一个参数 component 是list中url之后的第二个参数 往仓库里面添加deb包1aptly repo add repository_name packages_path 查看仓库里的包信息1aptly repo show -with-packages repository_name 删除软件包1234567$ aptly repo remove stable percona-server-client-5.5Loading packages...[-] percona-server-client-5.5_5.5.35-rel33.0-611.squeeze_i386 removed[-] percona-server-client-5.5_5.5.35-rel33.0-611.squeeze_amd64 removed$ aptly repo remove 3rd-party &apos;google-chrome-stable (&lt;122.0.6261.111-1)&apos;$ aptly db cleanup 发布软件包1aptly publish repo repository_name prefix repository_name 从repo（官方建议从snapshot发布）发布版本 prefix 可选项，这是url后面的文件夹路径名，最好还是加一个 更新发布1aptly publish update --force-overwrite -batch -passphrase=&quot;xxxxxxxx&quot; distribution prefix drop发布1aptly publish drop &lt;distribution&gt; [&lt;prefix&gt;] 使用Nginx假设服务器直接上配置文件 12345678910$ cat /etc/nginx/conf.d/aptly.confserver &#123; listen 60000; listen [::]:60000; server_name yourdomain.com; root /home/ubuntu/.aptly/public; index index.html allow all; autoindex on;&#125;]]></content>
      <categories>
        <category>aptly</category>
      </categories>
      <tags>
        <tag>aptly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux权限知识]]></title>
    <url>%2F2023%2F05%2F06%2FLinux%E6%9D%83%E9%99%90%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[权限的数值表示Linux的权限多数时候是3个数字表示r — read — 4w — write — 2x — executed — 1有时候会用4位数字表示，跟下面介绍的suid，sgid，sbit有关SUID-&gt;4SGID-&gt;2SBIT-&gt;1 UID 和 GIDUID属于user id，一般来说Linux的第一个非root用户的UID是1000GID属于组id，一般来说Linux的第一个非root用户组的GID是1000 特殊IDSUIDSUID是用来作用户提权的，比如说：12╰─ ll /usr/bin/sudo ─╯-rwsr-xr-x 1 root root 166056 Apr 4 19:56 /usr/bin/sudo* 这里表示sudo文件属于root用户，s（小写）表示sudo有可执行权限，其他用户执行这个sudo的时候会暂时获得root权限。 SGIDSGID针对于文件的功能跟SUID的功能一样当SGID作用于目录的时候，意义就非常重大。当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用 SGID 修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组 SBIT12╰─ ll -d /tmp ─╯drwxrwxrwt 25 root root 266240 May 6 21:18 /tmp/ 权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。 一些细节小写的s和t代表了文件或者文件夹可执行的权限，如果是大写的S和T的话，那就是这个文件或者文件夹没有可执行权限。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmake常用相关]]></title>
    <url>%2F2023%2F05%2F06%2Fcmake%E5%B8%B8%E7%94%A8%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[find_package检查需要的包的包名1234567╰─ dpkg -L libopencv-dev | grep 'cmake' /usr/lib/x86_64-linux-gnu/cmake/usr/lib/x86_64-linux-gnu/cmake/opencv4/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig-version.cmake/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVModules-release.cmake/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVModules.cmake 从上面的可以看到这个库的cmake文件是OpenCVConfig.cmake， 所以它的库名字是OpenCV, 所以CMakeLists.txt可以这么写：123find_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Not needed for CMake &gt;= 2.8.11target_link_libraries(MY_TARGET_NAME $&#123;OpenCV_LIBS&#125;) find_package 会对应设置以下几类变量： [PackageName]_FOUND: 如果找到了包，则会设置为TRUE，否则为FALSE。 [PackageName]_INCLUDE_DIRS 或 [PackageName]_INCLUDES: 包含目录列表，你可以用这个变量来将包含目录添加到你的项目中。 [PackageName]_LIBRARIES 或 [PackageName]_LIBS: 库文件列表，用来链接你的项目和依赖库。 [PackageName]_DEFINITIONS: 编译器定义列表，需要添加到你的编译器命令行中去，以便使用库。 Pkg-configpkgconfig需求的是一个pc文件，我们可以查找库的pc文件，同上面的方法12╰─ dpkg -L libopencv-dev | grep 'pc'/usr/lib/x86_64-linux-gnu/pkgconfig/opencv4.pc 这里找打了opencv4这个名字，需要写到pkg_check_modules的第三个参数 下面是一个CMakeLists.txt例子1234567891011121314151617181920212223242526# CMakeLists.txt# A sample CMake project that uses pkg-config to find a library (let's say, 'libexample')cmake_minimum_required(VERSION 3.0)project(ExampleProject)# It's a good practice to set the minimum required version of pkg-configfind_package(PkgConfig REQUIRED)# Use pkg-config to check if 'libexample' is installed on the systempkg_check_modules(LIBEXAMPLE REQUIRED libexample)# Include directories for 'libexample'include_directories($&#123;LIBEXAMPLE_INCLUDE_DIRS&#125;)# Link directories for 'libexample'link_directories($&#123;LIBEXAMPLE_LIBRARY_DIRS&#125;)# Add executable target with source filesadd_executable(example_executable main.cpp)# Link the executable to the required librarytarget_link_libraries(example_executable $&#123;LIBEXAMPLE_LIBRARIES&#125;)# Add any compiler definitions or compile options if necessaryadd_definitions($&#123;LIBEXAMPLE_CFLAGS_OTHER&#125;)]]></content>
      <categories>
        <category>Linux</category>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Systemd相关]]></title>
    <url>%2F2023%2F03%2F20%2Fsystemd%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[本文摘抄自 阮一峰的日志 常用命令123456789sudo systemctl enable httpdsudo systemctl disable httpdsudo systemctl start httpdsudo systemctl restart httpdsudo systemctl stop httpdsudo systemctl kill httpdsudo systemctl mask httpdsudo systemctl unmask httpdsudo systemctl status httpd 读懂配置文件一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。 前面说过，配置文件主要放在/usr/lib/systemd/system 目录，也可能在/etc/systemd/system 目录。找到配置文件以后，使用文本编辑器打开即可。 systemctl cat 命令可以用来查看配置文件，下面以 sshd.service 文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。 12345678910111213141516171819$ systemctl cat sshd.service[Unit]Description=OpenSSH server daemonDocumentation=man:sshd(8) man:sshd_config(5)After=network.target sshd-keygen.serviceWants=sshd-keygen.service[Service]EnvironmentFile=/etc/sysconfig/sshdExecStart=/usr/sbin/sshd -D $OPTIONSExecReload=/bin/kill -HUP $MAINPIDType=simpleKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target [Unit] 启动顺序和依赖关系1After 字段：表示如果 network.target 或 sshd-keygen.service 需要启动，那么 sshd.service 应该在它们之后启动。 相应地，还有一个 Before 字段，定义 sshd.service 应该在哪些服务之前启动。 注意，After 和 Before 字段只涉及启动顺序，不涉及依赖关系。 举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。 设置依赖关系，需要使用 Wants 字段和 Requires 字段。 123Wants 字段：表示 sshd.service 与 sshd-keygen.service 之间存在"弱依赖"关系，即如果"sshd-keygen.service"启动失败或停止运行，不影响 sshd.service 继续执行。Requires 字段则表示"强依赖"关系，即如果该服务启动失败或异常退出，那么 sshd.service 也必须退出。 注意，Wants 字段与 Requires 字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。 [Service] 启动行为启动命令许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。1EnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。 上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。 配置文件里面最重要的字段是ExecStart。1ExecStart字段：定义启动进程时执行的命令。 上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。 与之作用相似的，还有如下这些字段。12345ExecReload字段：重启服务时执行的命令ExecStop字段：停止服务时执行的命令ExecStartPre字段：启动服务之前执行的命令ExecStartPost字段：启动服务之后执行的命令ExecStopPost字段：停止服务之后执行的命令 请看下面的例子。 123456[Service]ExecStart=/bin/echo execstart1ExecStart=ExecStart=/bin/echo execstart2ExecStartPost=/bin/echo post1ExecStartPost=/bin/echo post2 上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。 123execstart2post1post2 所有的启动设置之前，都可以加上一个连词号（-），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd文件不存在，也不会抛出错误。 启动类型Type字段定义启动类型。它可以设置的值如下。123456simple（默认值）：ExecStart字段启动的进程为主进程forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务dbus：类似于simple，但会等待 D-Bus 信号后启动notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合 下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。 123456789[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off[Install]WantedBy=multi-user.target 上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。 如果关闭以后，将来某个时候还想打开，配置文件修改如下。 1234567891011[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off startExecStop=/usr/bin/touchpad-off stopRemainAfterExit=yes[Install]WantedBy=multi-user.target 上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。 重启行为Service区块有一些字段，定义了重启行为。1KillMode字段：定义 Systemd 如何停止 sshd 服务。 上面这个例子中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。 KillMode字段可以设置的值如下。1234control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉process：只杀主进程mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号none：没有进程会被杀掉，只是执行服务的 stop 命令。 接下来是Restart字段。1Restart字段：定义了 sshd 退出后，Systemd 的重启方式。 上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。 Restart字段可以设置的值如下。1234567no（默认值）：退出后不会重启on-success：只有正常退出时（退出状态码为0），才会重启on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启on-abnormal：只有被信号终止和超时，才会重启on-abort：只有在收到没有捕捉到的信号终止时，才会重启on-watchdog：超时退出，才会重启always：不管是什么退出原因，总是重启 对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。 最后是RestartSec字段。1RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。 [Install]区块Install区块，定义如何安装这个配置文件，即怎样做到开机启动。1WantedBy字段：表示该服务所在的 Target。 Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。 这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。 Systemd 有默认的启动 Target。 12$ systemctl get-defaultmulti-user.target 上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。 使用 Target 的时候，systemctl list-dependencies命令和systemctl isolate命令也很有用。 123456# 查看 multi-user.target 包含的所有服务$ systemctl list-dependencies multi-user.target# 切换到另一个 target# shutdown.target 就是关机状态$ sudo systemctl isolate shutdown.target 一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。 Targe的配置文件Target 也有自己的配置文件。123456789$ systemctl cat multi-user.target[Unit]Description=Multi-User SystemDocumentation=man:systemd.special(7)Requires=basic.targetConflicts=rescue.service rescue.targetAfter=basic.target rescue.service rescue.targetAllowIsolate=yes 注意，Target 配置文件里面没有启动命令。 上面输出结果中，主要字段含义如下。1234567Requires字段：要求basic.target一起运行。Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。 修改后重启12345# 重新加载配置文件$ sudo systemctl daemon-reload# 重启相关服务$ sudo systemctl restart foobar]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用配置]]></title>
    <url>%2F2022%2F11%2F15%2FLinux-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[gh指令说明123456gh repo list kaylorchengh repo create kaylorchen/demo --privategh repo clone kaylorchen/demogh run list --repo kaylorchen/demo # 显示ci的信息gh run view RUN_ID --repo kaylorchen/demogh run download RUN_ID --repo kaylorchen/demo -n git MQTT服务器部署使用emqx1docker run --restart=always -d --name emqx -v $&#123;PWD&#125;/data:/opt/emqx/data -v $&#123;PWD&#125;/log:/opt/emqx/log -p 18083:18083 -p 1883:1883 emqx 默认的账号密码是admin:public 传统mqtt服务器下载mqttx客户端 https://mqttx.app/downloads 用于测试 使用docker启动服务12345docker pull eclipse-mosquitto:2.0.20docker run --name mqtt -d -p 1883:1883 eclipse-mosquitto:2.0.20docker cp mqtt:/mosquitto $PWD/docker stop mqttdocker rm mqtt 修改配置文件 mosquitto/config/mosquitto.conf123456listener 1883 0.0.0.0persistence truepersistence_location /mosquitto/data/log_dest file /mosquitto/log/mosquitto.logallow_anonymous falsepassword_file /mosquitto/config/pwfile 正式启动123touch mosquitto/config/pwfiledocker run --restart=always -d --name mqtt -p 1883:1883 -v $&#123;PWD&#125;/mosquitto:/mosquitto eclipse-mosquitto:2.0.20docker exec -it mqtt mosquitto_passwd -c /mosquitto/config/pwfile kaylor ZSH 配置和 FZF 配置zsh 基本配置1234apt install zshgit clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh --depth=1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcchsh -s /bin/zsh 编辑~/.zshrc，修改一下on-my-zsh的默认插件和禁止其每次启动都启动更新, 请找到相应的行12zstyle ':omz:update' mode disabledplugins=(git sudo extract z cp safe-paste colored-man-pages) sudo插件是当你忘记加sudo的时候，连续按两次esc，就会在指令上添加sudoextract是解压指令，无脑解压各种压缩包，再也不需要查询参数了z是一个目录跳转指令，使用它替代cd的话，可以记录你的常用目录cp的使用指令是cpv，是一个带进度条的拷贝指令 添加插件在.zshrc 上添加如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243# zplug configruationif [[ ! -d &quot;$&#123;ZPLUG_HOME&#125;&quot; ]]; then if [[ ! -d ~/.zplug ]]; then git clone https://github.com/zplug/zplug ~/.zplug # If we can&apos;t get zplug, it&apos;ll be a very sobering shell experience. To at # least complete the sourcing of this file, we&apos;ll define an always-false # returning zplug function. if [[ $? != 0 ]]; then function zplug() &#123; return 1 &#125; fi fi export ZPLUG_HOME=~/.zplugfiif [[ -d &quot;$&#123;ZPLUG_HOME&#125;&quot; ]]; then source &quot;$&#123;ZPLUG_HOME&#125;/init.zsh&quot;fizplug &apos;plugins/git&apos;, from:oh-my-zsh, if:&apos;which git&apos;zplug &apos;romkatv/powerlevel10k&apos;, use:powerlevel10k.zsh-themezplug &quot;plugins/vi-mode&quot;, from:oh-my-zshzplug &apos;zsh-users/zsh-autosuggestions&apos;zplug &apos;zsh-users/zsh-completions&apos;, defer:2zplug &apos;zsh-users/zsh-history-substring-search&apos;zplug &apos;zsh-users/zsh-syntax-highlighting&apos;, defer:2if ! zplug check; then zplug installfizplug loadbindkey &apos;^K&apos; kill-linebindkey &apos;^B&apos; backward-charbindkey &apos;^F&apos; forward-charbindkey &apos;^U&apos; backward-kill-linezstyle &apos;:completion:*&apos; rehash trueunsetopt no_matchalias ll=&apos;ls -alF&apos;alias la=&apos;ls -A&apos;alias l=&apos;ls -CF&apos; 私人化指令配置有时候需要定制以下私人的指令，可以在 ~/.zshrc 文件中加入一行123[[ ! -f ~/.user.zsh ]] || source ~/.user.zsh或[[ ! -f ~/.user.bash ]] || source ~/.user.bash 然后创建并编辑 ~/.user.zsh 或者 ~/.user.bash, 输入你想要的指令12345678910111213alias open='nautilus'alias zsh_reload='source ~/.zshrc'_systemctl_unit_state() &#123; typeset -gA _sys_unit_state _sys_unit_state=( $(__systemctl list-unit-files "$PREFIX*" | awk '&#123;print $1, $2&#125;') ) &#125;function full_tar_with_sudo &#123; sudo tar -cvpzf $1 $2&#125;function full_untar_with_sudo &#123; sudo tar -xvpzf $1 -C $2&#125; 安装配置 fzf安装与升级 Install 12git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf~/.fzf/install Upgrade 1cd ~/.fzf &amp;&amp; git pull &amp;&amp; ./install 基础使用 基础操作 12fzf # 输入fzf直接搜索fzf -m # 多选模式 使用CTRL-J/CTRL-K(或者CTRL-N/CTRL-P)进行上下选择使用Enter选中条目, CTRL-C/ESC进行退出操作在多选择模式(-m), 使用TAB和Shift-TAB标记多个条目Emacs 风格按键绑定支持鼠标操作 语法匹配 标记 匹配类型 描述 sbtrkt 模糊匹配 内容匹配sbtrkt(字符匹配) ‘wild 精确匹配(单引号) 内容包含单词wild(单词匹配) ^music 前缀精确匹配 以music开头 .mp3$ 后缀精确匹配 以.mp3结尾 !fire 反转匹配 内容不包含fire !^music 前缀反转匹配 不以music开头 !.mp3$ 后缀反转匹配 不以.mp3结尾 fzf的过滤默认是与操作，每个与操作之间使用空格间隔，如果需要使用或操作，参考下面的例子：1^core go$ | rb$ | py$ # 表示以`core`开头, 且以`go`或`rb`或`py`结尾 一般快捷键和环境变量 按键 描述 CTRL-T 命令行打印选中内容 CTRL-R 命令行历史记录搜索, 并打印输出 ALT-C 模糊搜索目录, 并进入(cd)，macos可以使用 cd **[TAB] name description example FZF_DEFAULT_COMMAND 输入为 tty 时的默认命令 export FZF_DEFAULT_COMMAND=’fd –type f’ FZF_DEFAULT_OPTS 设置默认选项 export FZF_DEFAULT_OPTS=”–layout=reverse –inline-info” FZF_CTRL_T_COMMAND 按键映射行为设置 FZF_CTRL_T_OPTS 按键映射选项设置 FZF_CTRL_R_OPTS 按键映射选项设置 FZF_ALT_C_COMMAND 按键映射行为设置 FZF_ALT_C_OPTS 按键映射选项设置 个性化配置 更换搜索引擎(可选) 12brew install fd # Mac os apt install fd-find # Ubuntu Linux 设置环境FZF的环境变量 编辑 ~/.bashrc 或者 ~/.zshrc, 添加如下内容123export FZF_CTRL_T_COMMAND="fd --exclude=&#123;.git,.idea,.vscode,.sass-cache,node_modules,build&#125; --type f --follow --hidden --color=always"export FZF_DEFAULT_COMMAND="fd --exclude=&#123;.git,.idea,.vscode,.sass-cache,node_modules,build&#125; --type f --follow --hidden --color=always"export FZF_DEFAULT_OPTS="--height 60% --layout=reverse --preview '(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500' --ansi" FZF_DEFAULT_COMMAND 依赖于安装了fd搜索指令，如果没有安装，可以不设置。FZF_DEFAULT_OPTS 依赖于highlight指令，如果没有则会调用cat指令。Ubuntu可以通过apt install highlight安装该指令，MacOS可以通过brew install highlight安装该指令 shell命令补全 fzf默认使用 ** + [TAB] 进行补全，常用的补全指令有：12345kill -9 **vim **cd **ssh **export ** v4l2-ctl获取支持的分辨率和编码格式1v4l2-ctl --list-formats-ext -d /dev/video0 显示 Camera 所有信息(分辨率:Width/Height)1v4l2-ctl -d /dev/video0 --all 获取支持的编码格式1v4l2-ctl --list-formats -d /dev/video0 获取支持的 camera 设备1v4l2-ctl --list-devices -d /dev/video0 获取摄像头控制参数1v4l2-ctl -d /dev/video0 --list-ctrls Samba 相关挂载vers 参数要指定 12sudo mount //192.168.100.1/share/ share/ -o vers=2.0sudo mount //192.168.100.1/share/ share/ -o vers=2.0,uid=ubuntu,gid=ubuntu NFS 配置安装 NFS1sudo apt install nfs-kernel-server 配置共享目录服务端的共享目录配置文件为 /etc/exports 1234567891011# /etc/exports: the access control list for filesystems which may be exported# to NFS clients. See exports(5).## Example for NFSv2 and NFSv3:# /srv/homes hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)## Example for NFSv4:# /srv/nfs4 gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)# /srv/nfs4/homes gss/krb5i(rw,sync,no_subtree_check)#/home/ubuntu *(rw,anonuid=1000,anongid=1000,sync,no_subtree_check) 1&lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）] 输出目录： 服务器共享的绝对目录地址 客户端： 指定 ip 地址的主机：192.168.0.200 指定子网中的所有主机：192.168.0.0/24 192.168.0.0/255.255.255.0 指定域名的主机：david.bsmart.cn 指定域中的所有主机：*.bsmart.cn 所有主机：* 选项： 访问权限 只读 ro 读写 rw 用户映射选项 all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）； no_all_squash：与 all_squash 取反（默认设置）； root_squash：将 root 用户及所属组都映射为匿名用户或用户组（默认设置）； no_root_squash：与 rootsquash 取反； anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）； anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）； 其他选项 secure：限制客户端只能从小于 1024 的 tcp/ip 端口连接 nfs 服务器（默认设置）； insecure：允许客户端从大于 1024 的 tcp/ip 端口连接服务器； sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性； async：将数据先保存在内存缓冲区中，必要时才写入磁盘； wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）； no_wdelay：若有写操作则立即执行，应与 sync 配合使用； subtree_check：若输出目录是一个子目录，则 nfs 服务器将检查其父目录的权限(默认设置)； no_subtree_check：即使输出目录是一个子目录，nfs 服务器也不检查其父目录的权限，这样可以提高效率； 配置完成之后，重启 nfs service. 1sudo /etc/init.d/nfs-kernel-server restart 客户端 mount假设服务 IP 为: 192.168.20.200, 123456kaylor@kaylor-ThinkPad-T460:~$ showmount -e 192.168.20.200 #显示服务器共享的目录Export list for 192.168.20.200:/home/ubuntu *kaylor@kaylor-ThinkPad-T460:~$ sudo mount 192.168.20.200:/home/ubuntu nfs#mac mount需要加参数sudo mount -o vers=4,resvport 192.168.51.200:/home/ubuntu nfs iptables 网络转发设置设置内核转发 即时开启内核转发 1echo "1" &gt; /proc/sys/net/ipv4/ip_forward 永久开启内核转发 1234vim /etc/sysctl.conf=========================================================================net.ipv4.ip_forward = 1sysctl -p iptables 指令说明 PREROUTING(DNT)这是 chain 的前端，是用来改变目标地址的 FORWARD如果目标地址不是本机，机会进行转发。注意 linux 内核默认是禁止转发的，所以需要开启上面步骤的内核转发 POSTROUTING(SNAT)它的作用是修改数据包的源地址，比如内网 IP 访问公网 IP，出口路由会将数据包的源地址改为自己的公网 IP，否者数据包有去无回。 链操作操作参数 参数 描述 -I 插入 -A 追加 -R 替换 -D 删除 -L 列表显示 过滤参数 参数 描述 -s 匹配源地址 -d 匹配目的地址 -p 协议匹配 -i 入接口匹配 -o 出接口匹配 –sport，–dport 源和目的端口匹配 -j 跳转,也就是包的方向 ! 取反 列出 nat 表的所有规则 1iptables -t nat -n -L 使用 -n 选项是因为避免长时间的反向 DNS 查询 添加一个规则到 filter 表的 FORWARD 链 1iptables -t filter -A FORWARD -s 10.1.1.11 -d 202.1.1.1 -j ACCEPT 在 iptables 中，默认的表名就是 filter，所以这里可以省略-t filter 直接写成: iptables -A FORWARD -s 10.1.1.11 -d 202.1.1.1 -j ACCEPT 允许 eth3 接口过来的包通过 FORWARD 链 1iptables -A FORWARD -i eth3 -j ACCEPT 简单 nat 路由器 环境介绍 linux 2.4 +2 个网络接口Lan 口:10.1.1.254/24 eth0Wan 口:60.1.1.1/24 eth1目的：实现内网中的节点（10.1.1.0/24）可控的访问 internet。首先将 Lan 的节点 pc 的网关指向 10.1.1.254。 确定你的 linux 的 ip 配置无误，可以正确的 ping 通内外的地址。同时用 route 命令查看 linux 的本地路由表，确认指定了可用的 ISP 提供的默认网关。 操作 打开 linux 的转发功能：sysctl net.ipv4.ip_forward=1 将 FORWARD 链的策略设置为 DROP，这样做的目的是做到对内网 ip 的控制，你允许哪一个访问 internet 就可以增加一个规则，不在规则中的 ip 将无法访问 internet. 1iptables -P FORWARD DROP 这条规则规定允许任何地址到任何地址的确认包和关联包通过。一定要加这一条，否则你只允许 lan IP 访问没有用 1iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 这条规则做了一个 SNAT，也就是源地址转换，将来自 10.1.1.0/24 的地址转换为 60.1.1.1 (因为是让内网上网，因此对于代理服务器而言 POSTROUTING（经过路由之后的包应该要把源地址改变为 60.1.1.1，否则包无法返回）) 1iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -j SNAT --to 60.1.1.1 有这几条规则，一个简单的 nat 路由器就实现了。这时你可以将允许访问的 ip 添加至 FORWARD 链，他们就能访问 internet 了。 比如我想让 10.1.1.9 这个地址访问 internet,那么你就加如下的命令就可以了。 1iptables -A FORWARD -s 10.1.1.9 -j ACCEPT 也可以精确控制他的访问地址,比如我就允许 10.1.1.99 访问 3.3.3.3 这个 ip 1iptables -A FORWARD -s 10.1.1.99 -d 3.3.3.3 -j ACCEPT 或者只允许他们访问 80 端口 1iptables -A FORWARD -s 10.1.1.0/24 -p tcp --dport http -j ACCEPT 端口转发123iptables -t nat -A PREROUTING -d 10.8.1.24 -p tcp --dport 80 -j DNAT --to 192.168.111.111:80iptables -A FORWARD -d 192.168.111.111 -p tcp --dport 80 -j ACCEPTiptabels -t nat -A POSTROUTING -d 192.168.111.111 -p tcp --dport 80 -j SNAT --to 192.168.111.1 借鉴此链接 保存 iptables 指令 使用 iptables-restore设置了相关规则之后，保存到文件中 12iptables-save &gt; /etc/iptables-rulesip6tables-save &gt; /etc/ip6tables-rules 然后新建一个脚本文件，保存到/etc/network/if-pre-up.d/目录下，记得修改脚本的权限： 12#!/bin/bashiptables-restore &lt; /etc/iptables.rules 使用 iptables-persistent 1sudo apt install iptables-persistent 每当设置了新的 iptables 规则后，使用如下命令保存规则即可，规则会根据 ipv4 和 ipv6 分别保存在了/etc/iptables/rules.v4 和/etc/iptables/rules.v6 文件中。 1netfilter-persistent save 日志相关命令相关显示全部最近一次重新引导后收集到的 journal 条目 1journalctl -b 要查看上次引导的 journal 记录，则可使用-1 相对指针配合-b 标记 1journalctl -b -1 通过以下命令查看全部 2015 年 1 月 10 日下午 5：15 之后的条目 1234journalctl --since &quot;2015-01-10 17:15:00&quot;journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;journalctl --since 09:00 --until &quot;1 hour ago&quot;journalctl –-since yesterday 过滤 12345journalctl -u nginx.servicejournalctl -u nginx.service --since todayjournalctl _PID=8088journalctl _UID=33 --since todayjournalctl /path/to/executable_file 显示内核信息 1journalctl -k 根据优先级显示0: emerg1: alert2: crit3: err4: warning5: notice6: info7: debug 1journalctl -p err -b 显示近期日志 1journalctl -n 20 追踪日志/实时滚动日志 12journalctl -fjournalctl -u nginx.service -f 查看和删除系统日志 123journalctl --disk-usagejournalctl --vacuum-size=10M # 删除系统日志，只剩10Mjournalctl --vacuum-time=1min #删除一分钟之前的系统日志 查看 journald 进程信息 1sudo systemctl status systemd-journald.service 更换系统log和开启log滚动12sudo apt install syslog-ngsudo apt install logrotate 编码中使用系统 log安装依赖库 1apt install -y libsystemd-dev 相关函数 123456#include &lt;systemd/sd-journal.h&gt;int sd_journal_print(int priority, const char *format, ...);int sd_journal_printv(int priority, const char *format, va_list ap);int sd_journal_send(const char *format, ...);int sd_journal_sendv(const struct iovec *iov, int n);int sd_journal_perror(const char *message); The priority value is one of LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG, as defined in syslog.h find 指令指定目录搜索文件 12find dir -name &quot;*pppoe*&quot;find dir -perm /u+x -type f #查找dir下的可执行文件 Linux 内核编译指令配置 config 文件 1234make menuconfig# 跨平台配置的注意事项，比如export CROSS_COMPILE=/home/kaylor/rk3588/rk3588_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-make ARCH=arm64 menuconfig 根据已有的.config 文件，补充缺失的配置 1make defconfig 编译内核和模块 1make 单独编译模块和安装（不要轻易安装内核模块，如果不指定安装路径，容易损坏系统） 12make modulesmake modules_install INSTALL_MOD_PATH=安装路径 指定内核源码和模块源码所在的绝对路径 12make -C 内核源码绝对路径 M=模块源码文件所在的绝对路径 modulesmake ARCH=arm CROSS_COMPILE= -C /lib/modules/5.10.17-v7l+/build M=/home/pi/rtl8812au modules 安装模块具体操作 12install -p -m 644 88XXau.ko /lib/modules/5.10.17-v7l+/kernel/drivers/net/wireless//sbin/depmod -a 5.10.17-v7l+ 安装内核头文件 1make headers_install INSTALL_HDR_PATH=安装路径 nohup 指令nohup 即不挂起，不会因为终端退出而终结比如编译 Openwrt 1nohup make -j1 V=s &gt;&amp; make.log &amp; 2&gt;&amp;1 客户定制 USB 设备号驱动加载123456sudo modprobe -r em28xxecho "modprobe finished"sudo modprobe em28xx card=65echo "em28xx configured"sudo su -c "echo '2694 0008' &gt; /sys/bus/usb/drivers/em28xx/new_id"echo "Custom VID and PID enabled" nload 分析网卡流量12345678910111213141516171819202122232425-a period Sets the length in seconds of the time window for average calculation. Default is 300.-i max_scaling Specifies the 100% mark in kBit/s of the graph indicating the incoming bandwidth usage. Ignored if max_scaling is 0 or the switch -m is given. Default is 10240.-m Show multiple devices at a time; no traffic graphs.-o max_scaling Same as -i but for the graph indicating the outgoing bandwidth usage. Default is 10240.-t interval Determines the refresh interval of the display in milliseconds. Default is 500.-u h|b|k|m|g Sets the type of unit used for the display of traffic numbers. H|B|K|M|G h: auto, b: Bit/s, k: kBit/s, m: MBit/s etc. H: auto, B: Byte/s, K: kByte/s, M: MByte/s etc. Default is h.-U h|b|k|m|g Same as -u, but for a total amount of data (without &quot;/s&quot;). H|B|K|M|G Default is H.devices Network devices to use. Default is to use all auto-detected devices.--help-h Print this help.example: nload -t 200 -i 1024 -o 128 -U M SSH服务器端编辑 /etc/ssh/sshd_config 12ClientAliveInterval 30ClientAliveCountMax 6 ClientAliveInterval 表示每隔多少秒，服务器端向客户端发送心跳，是的，你没看错。 下面的 ClientAliveInterval 表示上述多少次心跳无响应之后，会认为 Client 已经断开。 所以，总共允许无响应的时间是 60*3=180 秒。 客户端编辑 /etc/ssh/ssh_config 12ServerAliveInterval 30ServerAliveCountMax 100 MacOS ssh转发ssh的转发一般来说只要添加-A选项就可以了，但是macos默认没有把自己的秘钥添加，所以12ssh-add -lssh-add ~/.ssh/id_rsa 无法打开到身份验证代理的连接意味着您的计算机无法与身份验证代理程序通信。这通常发生在尝试使用SSH密钥进行身份验证时。要解决此问题，请执行以下步骤： 确保您的身份验证代理正在运行：运行以下命令检查代理是否已启动：1eval &quot;$(ssh-agent -s)&quot; 如果代理未运行，请运行以下命令启动代理：1ssh-agent /bin/bash 添加您的SSH私钥：运行以下命令将私钥添加到身份验证代理：1ssh-add /path/to/your/private_key 如果您的私钥位于默认位置（如~/.ssh/id_rsa），则无需指定路径。 如果上述步骤不起作用，请尝试重新启动SSH服务：sudo service ssh restart 如果问题仍然存在，请确保您的SSH私钥文件存在且您具有正确的访问权限。如果问题仍然无法解决，可能需要进一步调查您的操作系统和SSH配置。 X11应用转发服务端安装X11服务和测试app1apt install xorg x11-utils 客户端使用-X选项连接，并运行xclock测试123ssh kaylor@192.168.111.222 -Xxclock # 该指令运行在ssh的终端中 TMUX在 home 目录下创建 .tmux.conf 文件 12setw -g mode-keys viset -g default-terminal "screen-256color" VIM编辑 /etc/vim/vimrc 123456789set relativenumberset numbercolorscheme desertset ts=4set expandtabset pasteset encoding=utf8set laststatus=2 &quot; 设置状态栏在倒数第2行set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%04l,%04v][%p%%]\ [LEN=%L] GRUB让 grub 记住你上一次的启动项编辑 /etc/default/grub 12GRUB_DEFAULT=savedGRUB_SAVEDEFAULT=true 设置网卡名字为 eth*的形式 1GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0" 执行指令更新 grub 1update-grub 用户管理 添加一个组 1groupadd groupname 添加一个新用户 1adduser new_user 更改用户名 使用 root 用户登录 1234killall -u old_usernameusermod -l new_username old_usernamegroupmod -n new_groupname old_groupnameusermod -d /home/new_username new_username -m 添加现有用户到一个组： 1usermod -a -G groupname username 同时将 user 增加到 admins, ftp, www, 和 developers 用户组中，可以输入以下命令： 1useradd -G admins,ftp,www,developers user 查看用户的 ID 信息 1id username 文件传输 rsync 拷贝文件不改变文件的权限和属性，记得使用sudo:1234567891011121314sudo rsync -avz /path/to/source/ /path/to/destination/ # 同步source文件夹下的所有文件 sudo rsync -avz /path/to/source /path/to/destination/ # 同步source文件夹``` 以下命令将从源目录拷贝所有文件和子目录到目标目录，但不拷贝符号链接:```bashrsync -av --no-links /path/to/source/ /path/to/destination/``` 如果您想要拷贝符号链接的目标文件，可以使用“-L”选项，如下所示：```bashrsync -avL /path/to/source/ /path/to/destination/``` 请注意，“-L”选项会将符号链接的目标文件拷贝到目标目录中，而不是链接本身。如果您想要拷贝链接本身，可以使用“-a”选项和“--copy-links”选项，如下所示：```bashrsync -a --copy-links /path/to/source/ /path/to/destination/ 这将拷贝符号链接本身，而不是链接的目标文件。 网络抓包基础下面是一些用来配置 tcpdump 的选项，它们非常容易被遗忘，也容易和其它类型的过滤器比如Wireshark等混淆。 选项 -i any 监听所有的网卡接口，用来查看是否有网络流量 -i eth0 只监听eth0网卡接口 -D 显示可用的接口列表 -n 不要解析主机名 -nn 不要解析主机名或者端口名 -q 显示更少的输出(更加quiet) -t 输出可读的时间戳 -tttt 输出最大程度可读的时间戳 -X 以hex和ASCII两种形式显示包的内容 -XX 与 -X类似，增加以太网header的显示 -v, -vv, -vvv 显示更加多的包信息 -c 只读取x个包，然后停止 -s 指定每一个包捕获的长度，单位是byte，使用-s0可以捕获整个包的内容 -S 输出绝对的序列号 -e 获取以太网header -E 使用提供的秘钥解密IPSEC流量 表达式在tcpdump中，可以使用表达式过滤指定类型的流量。有三种主要的表达式类型：type，dir，proto。 类型（type）选项包含：host，net，port 方向（dir）选项包含：src，dst 协议（proto）选项包含：tcp，udp，icmp，ah等 示例捕获所有流量查看所有网卡接口上发生了什么 tcpdump -i any 指定网卡接口查看指定网卡上发生了什么 tcpdump -i eth0 原生输出查看更多的信息，不解析主机名和端口号，显示绝对序列号，可读的时间戳 tcpdump -ttttnnvvS 查看指定IP的流量这是最常见的方式，这里只查看来自或者发送到IP地址1.2.3.4的流量。 tcpdump host 1.2.3.4 查看更多的包信息，输出HEX当你需要查看包中的内容时，使用hex格式输出是非常有用的。 # tcpdump -nnvXSs 0 -c1 icmp tcpdump: data link type PKTAP tcpdump: listening on pktap, link-type PKTAP (Apple DLT_PKTAP), capture size 262144 bytes 16:08:16.791604 IP (tos 0x0, ttl 64, id 34318, offset 0, flags [none], proto ICMP (1), length 56) 192.168.102.35 &gt; 114.114.114.114: ICMP 192.168.102.35 udp port 50694 unreachable, length 36 IP (tos 0x0, ttl 152, id 0, offset 0, flags [none], proto UDP (17), length 112) 114.114.114.114.53 &gt; 192.168.102.35.50694: [|domain] 0x0000: 5869 6c88 7f64 784f 4392 ed7e 0800 4500 Xil..dxOC..~..E. 0x0010: 0038 860e 0000 4001 e906 c0a8 6623 7272 .8....@.....f#rr 0x0020: 7272 0303 3665 0000 0000 4500 0070 0000 rr..6e....E..p.. 0x0030: 0000 9811 16cd 7272 7272 c0a8 6623 0035 ......rrrr..f#.5 0x0040: c606 005c 0000 ...\.. 1 packet captured 357 packets received by filter 0 packets dropped by kernel 使用源和目的地址过滤tcpdump src 2.3.4.6 tcpdump dst 3.4.5.6 过滤某个子网的数据包tcpdump net 1.2.3.0/24 过滤指定端口相关的流量tcpdump port 3389 tcpdump src port 1025 过滤指定协议的流量tcpdump icmp 只显示IPV6流量tcpdump ip6 使用端口范围过滤tcpdump portrange 21-23 基于包的大小过滤流量tcpdump less 32 tcpdump greater 64 tcpdump &lt;=128 将捕获的内容写入文件使用-w选项可以将捕获的数据包信息写入文件以供以后分析，这些文件就是著名的PCAP(PEE-cap)文件，很多应用都可以处理它。 tcpdump port 80 -w capture_file 使用tcpdump加载之前保存的文件进行分析 tcpdump -r capture_file 高级使用组合语句可以完成更多高级的过滤。 AND: and or &amp;&amp; OR: or or || EXCEPT: not or ! 过滤指定源IP和目的端口tcpdump -nnvvS src 10.5.2.3 and dst port 3389 过滤指定网络到另一个网络比如下面这个，查看来自192.168.x.x的，并且目的为10.x或者172.16.x.x的所有流量，这里使用了hex输出，同时不解析主机名 tcpdump -nvX src net 192.168.0.0/16 and dst net 10.0.0.0/8 or 172.16.0.0/16 过滤到指定IP的非ICMP报文tcpdump dst 192.168.0.2 and src net and not icmp 过滤来自非指定端口的指定主机的流量下面这个过滤出所有来自某个主机的非ssh流量 tcpdump -vv src mars and not dst port 22 复杂分组和特殊字符当构建复杂的过滤规则的时候，使用单引号将规则放到一起是个很好的选择。特别是在包含()的规则中。比如下面的规则就是错误的，因为括号在shell中会被错误的解析，可以对括号使用\进行转义或者使用单引号 tcpdump src 10.0.2.3 and (dst port 3389 or 22) 应该修改为 tcpdump &apos;src 10.0.2.3 and (dst port 3389 or 22)&apos; 隔离指定的TCP标识可以基于指定的TCP标识（flag）来过滤流量。 下面的过滤规则中，tcp[13] 表示在TCP header中的偏移位置13开始，后面的数字代表了匹配的byte数。 显示所有的URGENT (URG)包tcpdump &apos;tcp[13] &amp; 32!=0&apos; 显示所有的ACKNOWLEDGE (ACK)包tcpdump &apos;tcp[13] &amp; 16!=0&apos; 显示所有的PUSH(PSH)包tcpdump &apos;tcp[13] &amp; 8!=0&apos; 显示所有的RESET(RST)包tcpdump &apos;tcp[13] &amp; 4!=0&apos; 显示所有的SYNCHRONIZE (SYN) 包tcpdump &apos;tcp[13] &amp; 2!=0&apos; 显示所有的FINISH(FIN)包tcpdump &apos;tcp[13] &amp; 1!=0&apos; 显示说有的SYNCHRONIZE/ACKNOWLEDGE (SYNACK)包tcpdump &apos;tcp[13]=18&apos; 其它方式与大多数工具一样，也可以使用下面这种方式来捕获指定TCP标识的流量 tcpdump &apos;tcp[tcpflags] == tcp-syn&apos; tcpdump &apos;tcp[tcpflags] == tcp-rst&apos; tcpdump &apos;tcp[tcpflags] == tcp-fin&apos; 识别重要流量最后，这里有一些重要的代码片段你可能需要，它们用于过滤指定的流量，例如畸形的或者恶意的流量。 过滤同时设置SYN和RST标识的包（这在正常情况下不应该发生）tcpdump &apos;tcp[13] = 6&apos; 过滤明文的HTTP GET请求tcpdump &apos;tcp[32:4] = 0x47455420&apos; 通过横幅文本过滤任意端口的SSH连接tcpdump &apos;tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D&apos; 过滤TTL小于10的包（通常情况下是存在问题或者在使用traceroute）tcpdump &apos;ip[8] &lt; 10&apos; 过滤恶意的包tcpdump &apos;ip[6] &amp; 128 != 0&apos; GIT 变基 12git checkout experimentgit rebase -i master # 这里是就是把experiment当做枝条剪下来，嫁接到master上，base到master上的意思 一般的合并 把 dev 合并到 master 12git checkout mastergit merge dev 分支重命名 本地分支重命名1git branch -m new_name 远程分支重命名为本地分支名1git branch -m &lt;旧分支名&gt; &lt;新分支名&gt; 解绑上游分支 1git branch --unset-upstream clone 指定分支 1git clone -b dev_branch [url] –depth=1 参数，克隆最近一次的 commit 的，体积会变小 1git clone https://github.com/xxx/xxx.git --depth=1 如果需要间该分支所有的 commit 克隆下来，需要 1git fetch --unshallow 但会产生另外一个问题，他只会把默认分支 clone 下来，其他远程分支并不在本地，所以这种情况下，需要用如下方法拉取其他分支： 1234git remote show origingit remote set-branches --add origin '*'git fetch origin your_branchgit checkout your_branch git bash 显示中文 1git config --global core.quotepath false 取消文件跟踪 1234git rm -r --cached dir #不跟踪，但保留文件git rm -r --f dir #删除文件git rm --cached readme.txt #不跟踪，但保留文件git rm --f readme.txt #删除文件 远程仓库(remote) 1234git remote add origin [url]git remote set-url origin [url] # 更换URLgit remote –v # 查看remote信息git remote remove origin # 取消远程关联 推送分支 12git push --set-upstream origin mastergit push --all origin 拉取远程分支 1234git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin develop:develop #拉取远程分支中的develop分支和本地develop分支mergegit pull origin develop #拉取远程分支中的develop与当前分支mergegit pull --all 查看分支，并 checkout 12git branch –avgit checkout -t origin/xxx 删除本地分支 删除 merge 了的分支 1git branch -d xxx 删除分支（不管它有没有 merge） 1git branch -D xxx 删除远程分支 1git push origin --delete branch_name 远程分支已经删除，删除本地的origin/branch引用1git branch -d -r origin/branch 远程分支和本地代码都删除1git branch -D -r origin/branch 补丁 12git format-patch xxxxxxxxxxgit am *.patch 修改 commit 的 message 1git commit --amend -m "I miss you" 代理 加代理 123456git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080'git config http.proxy 'socks5://127.0.0.1:1080'git config https.proxy 'socks5://127.0.0.1:1080'#只对github.comgit config --global http.https://github.com.proxy socks5://127.0.0.1:1080 取消代理 12345git config --global --unset http.https://github.com.proxygit config --global --unset http.proxygit config --global --unset https.proxygit config --unset http.proxygit config --unset https.proxy Linux 配置文件 编辑全局配置文件 ~/.gitconfig 12345678[user] email = you@example.com[https] proxy = socks://192.168.15.1:10808[http] proxy = socks://192.168.15.1:10808[core] editor = vim tag 使用 123git tag v1.0.0git push --taggit tag -d v1.0.0 ROS 常用指令 配置 ROS 环境变量（临时） 12export ROS_IP=192.168.15.147export ROS_MASTER_URI="http://192.168.15.3:11311" 设置 ROS Log 等级 1rqt_logger_level Ubuntu 启动分析12systemd-analyze plot &gt; boot.svgsystemd-analyze blame 分区自动挂载和格式化格式化分区的时候使用 -E root_owner=1000:1000 选项1sudo mkfs.ext4 -E root_owner=1000:1000 /dev/sda1 确认系统有autofs4内核模块的支持，如果没有将不能使用x-systemd.automount选项，编辑/etc/fstab，添加1/dev/sda1 /opt/storage ext4 nofail,user,exec,rw,x-systemd.automount 0 0 x-systemd.automount选项是使用是挂载，没有使用的时候不挂载。 网络配置netplan 网络配置编辑 /etc/netplan/50-cloud-init.yaml 123456789101112131415161718192021# This file is generated from information provided by# the datasource. Changes to it will not persist across an instance.# To disable cloud-init&apos;s network configuration capabilities, write a file# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:# network: &#123;config: disabled&#125;network: version: 2 ethernets: eth0: dhcp4: true match: macaddress: b8:27:eb:d2:d7:1e set-name: eth0 optional: true wifis: wlan0: dhcp4: true optional: true access-points: &quot;Xiaomi_kaylordut_5G&quot;: password: &quot;kaylordut.com&quot; IP 指令 ipv4: 1ip -4 addr ipv6: 1ip -6 addr 基本网卡操作: 1234567891011ip addr show eth0ip addr list eth0ip addr show dev eth0sudo ip addr add 10.20.0.15/24 dev eth1sudo ip addr del 10.20.0.15/24 dev eth1sudo ip link set dev eth1 upsudo ip link set dev eth1 downip rip routeip route showip route list 添加和删除路由和默认网关 1234ip route add default via 192.168.1.254ip route add 192.168.0.0/24 via 192.168.1.1 dev eth0ip route del 192.168.0.0/24 via 192.168.1.1 dev eth0route add default gw 192.168.1.254 特殊路由 路由查找遵循“最长匹配原则”，当路由器收到一个IP数据包时，会将数据包的目的IP地址与自己本地路由表中的表项进行bit by bit的逐位查找，直到找到匹配度最长的条目，这叫最长匹配原则。最简单的理解方式就是，当路由都匹配的时候，看看谁的子网掩码位数比较多。 12ip route add 0.0.0.0/1 via 192.168.23.1 dev eth0ip route add 128.0.0.0/1 via 192.168.23.1 dev eth0 静态 IP 和 DNS 设置 设置静态 IP 123456789101112hunter@hunter-Drone:~$ cat /etc/network/interfaces# interfaces(5) file used by ifup(8) and ifdown(8)auto loiface lo inet loopbackauto eth0iface eth0 inet staticaddress 192.168.111.205netmask 255.255.255.0gateway 192.168.111.1dns-nameservers 192.168.111.1hwaddress ether 70:f7:54:55:0b:9a 为了支持 DNS，需要安装 apt install resolvconf ifupdown如果为了保证有一个固定的 DNS，可以编辑 /etc/resolvconf/resolv.conf.d/tail, 添加一个默认 DNS 12nameserver 114.114.114.114nameserver 119.29.29.29 桥接多网口 安装桥接工具 sudo apt install bridge-utils , 生成网桥配置文件 /etc/network/interfaces.d/br0 ，你会看到如下内容： 1234567891011auto br0iface br0 inet staticbridge_ports eth0 eth1address 192.168.23.10netmask 255.255.255.0gateway 192.168.23.100auto br0:0iface br0:0 inet staticaddress 192.168.100.101netmask 255.255.255.0 interfaces的一些特殊配置 pre-up 网卡启动前的动作 up 启动时的动作 post-up 启动后的动作 down 关闭时的动作 pre-down 关闭前的动作 post-down 关闭后的动作 比如我们在网卡启动之后添加特殊的路由表123456auto eth0iface eth0 inet staticaddress 192.168.23.10netmask 255.255.255.0post-up ip route add 128.0.0.0/1 via 192.168.23.1post-up ip route add 0.0.0.0/1 via 192.168.23.1 CAN 接口配置 1234567891011121314edge@host-63b5d7:/etc/network/interfaces.d$ cat can0auto can0iface can0 inet manualpre-up ip link set $IFACE type can bitrate 500000pre-up ip link set $IFACE type can restart-ms 1edge@host-63b5d7:/etc/network/interfaces.d$ ip -d -s link show can05: can0: &lt;NOARP,UP,LOWER_UP,ECHO&gt; mtu 16 qdisc pfifo_fast state UP mode DEFAULT group default qlen 10 link/can promiscuity 0 can state ERROR-ACTIVE (berr-counter tx 0 rx 0) restart-ms 1 bitrate 498701 sample-point 0.870 tq 26 prop-seg 33 phase-seg1 33 phase-seg2 10 sjw 1 mttcan: tseg1 2..255 tseg2 0..127 sjw 1..127 brp 1..511 brp-inc 1 mttcan: dtseg1 1..31 dtseg2 0..15 dsjw 1..15 dbrp 1..15 dbrp-inc 1 clock 38400000numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 无线网络配置123456kaylor@kaylor-ThinkPad-T460:~$ wpa_passphrase ssid passwordnetwork=&#123; ssid="ssid" #psk="password" psk=44116ea881531996d8a23af58b376d70f196057429c258f529577a26e727ec1b&#125; 使用以上指令生成配置文件，然后在 /etc/network/interfaces.d/ 下建立 wlan0 文件，内容如下： 12345678allow-hotplug wlan0iface wlan0 inet manualwpa-roam /etc/wpa_supplicant/wpa.confiface default inet staticaddress 192.168.20.200netmask 255.255.255.0gateway 192.168.20.1dns-nameservers 192.168.20.1 如果不使用指定的配置文件，也可以如下： 12345auto wlan0allow-hotplug wlan0iface wlan0 inet dhcpwpa-ssid &quot;GUEST&quot;wpa-psk &quot;sangfor123&quot; 网络启动等待的问题有时候设置了接口的DHCP服务，网络会一直在等待，最后只有网络服务启动超时了，才能启动系统。可以通过修改启动超时参数达到目的。 12345678910111213141516171819202122╰─ cat /lib/systemd/system/networking.service [Unit]Description=Raise network interfacesDocumentation=man:interfaces(5)DefaultDependencies=noRequires=ifupdown-pre.serviceWants=network.targetAfter=local-fs.target network-pre.target apparmor.service systemd-sysctl.service systemd-modules-load.service ifupdown-pre.serviceBefore=network.target shutdown.target network-online.targetConflicts=shutdown.target[Install]WantedBy=multi-user.targetWantedBy=network-online.target[Service]Type=oneshotEnvironmentFile=-/etc/default/networkingExecStart=/sbin/ifup -a --read-environmentExecStop=/sbin/ifdown -a --read-environment --exclude=loRemainAfterExit=trueTimeoutStartSec=5s 为再缩短启动时间，我们可以设置系统的systemd的默认启动超时时间，编辑 /etc/systemd/system.conf, 添加以下内容：12DefaultTimeoutStartSec=10sDefaultTimeoutStopSec=10s NetworkManager 管理相关永久不管理接口 查看网卡状态 1nmcli device status 编辑文件 /etc/NetworkManager/conf.d/99-unmanaged-devices.confNetworkManager 的系统配置文件可能的位置还有 /lib/NetworkManager/conf.d/ 和 /usr/lib/NetworkManager/conf.d/ 12[keyfile]unmanaged-devices=interface-name:interface_1;interface-name:interface_2;... 重启服务 1systemctl reload NetworkManager 临时更改接口管理状态1nmcli device set enp1s0 managed no/yes NAT 转发设置使用主机作为网关给其他设备上网 12345echo "Forward setting"sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADEsudo iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPTsudo iptables -A FORWARD -s 192.168.111.0/24 -j ACCEPTsudo sysctl -w net.ipv4.ip_forward=1 iw 指令 (无线网络)123456789101112131415161718192021iw help # 帮助iw list # 获得所有设备的功能，如带宽信息（2.4GHz，和5GHz），和802.11n的信息iw dev wlan0 scan # 扫描iw event # 监听事件iw dev wlan0 link # 获得链路状态iw wlan0 connect foo # 连接到已禁用加密的AP，这里它的SSID是fooiw wlan0 connect foo 2432 # 假设你有两个AP SSID 都是 foo ，你知道你要连接的是在 2432 频道iw wlan0 connect foo keys 0:abcde d:1:0011223344 # 连接到使用WEP的APiw dev wlan1 station dump # 获取station 的统计信息iw dev wlan1 station get # 获得station对应的peer统计信息iw wlan0 set bitrates legacy-2.4 12 18 24 # 修改传输比特率iw dev wlan0 set bitrates mcs-5 4 # 修改tx HT MCS的比特率iw dev wlan0 set bitrates mcs-2.4 10iw dev wlan0 set bitrates mcs-5 # 清除所有 tx 比特率和设置的东西来恢复正常iw dev set txpower &lt;auto|fixed|limit&gt; [&lt;tx power in mBm&gt;] #设置传输功率iw phy set txpower &lt;auto|fixed|limit&gt; [&lt;tx power in mBm&gt;] #设置传输功率iw dev wlan0 set power_save on #设置省电模式iw dev wlan0 get power_save #查询当前的节电设定iw phy phy0 interface add moni0 type monitor #添加一个 monitor 接口iw wlan0 info #查看当前网络状态iw phy0 info #查看phy0物理网卡信息 Python 的简易 httpserver12python -m SimpleHTTPServer 8080python3 -m http.server 8080 Udev 检查指令查看某个设备的详细信息，如/dev/video0 1udevadm info -a /dev/video0 编辑匹配规则（/etc/udev/rules.d/10-local.rules）:规则中只能包含单个父设备 1234567891011#map cameras to clear namesKERNEL==&quot;video*&quot;, ATTRS&#123;manufacturer&#125;==&quot;RoboteX&quot;, ATTRS&#123;product&#125;==&quot;Drive Camera&quot;, SYMLINK+=&quot;drive&quot;KERNEL==&quot;video*&quot;, ATTRS&#123;manufacturer&#125;==&quot;RoboteX&quot;, ATTRS&#123;product&#125;==&quot;PTZ Camera&quot;, SYMLINK+=&quot;ptz&quot;KERNEL==&quot;video*&quot;, ATTRS&#123;manufacturer&#125;==&quot;RoboteX&quot;, ATTRS&#123;product&#125;==&quot;Arm Camera&quot;, SYMLINK+=&quot;armCam&quot;KERNEL==&quot;video*&quot;, ATTRS&#123;manufacturer&#125;==&quot;RoboteX&quot;, ATTRS&#123;product&#125;==&quot;USB2.0 Camera&quot;, SYMLINK+=&quot;radCam&quot;#map storage device to clear nameKERNEL==&quot;mmcblk?p1&quot;, ATTRS&#123;vendor&#125;==&quot;0x8086&quot;, ATTRS&#123;device&#125;==&quot;0x0f16&quot;, SYMLINK+=&quot;storage&quot;#KERNEL==&quot;mmcblk?p2&quot;, SYMLINK+=&quot;storage&quot;KERNEL==&quot;sd?1&quot;, KERNELS==&quot;1-4.4:1.0&quot;, SYMLINK+=&quot;storage&quot;KERNEL==&quot;wlan*&quot;, SUBSYSTEMS==&quot;usb&quot;, NAME=&quot;wfb&quot; 重命名网卡 12KERNEL==&quot;wlan*&quot;, SUBSYSTEMS==&quot;sdio&quot;, NAME=&quot;hostapd&quot;KERNEL==&quot;wlan*&quot;, SUBSYSTEMS==&quot;usb&quot;, NAME=&quot;wfb&quot; 触发规则 1sudo udevadm trigger 查看文件夹大小12345dudu --max-depth=0 ./du -k ./du -m ./du -h ./ dd 指令 生成空的 image 和扩容 12dd if=/dev/zero of=disk.img bs=1M count=256 #生成256MBytes的imagecat blank.img &gt;&gt; old.img #将blank.img追加到old.img之后 追加之后的扩容操作，需要参考接下来的“使用 parted 扩容分区”，对 image 进行分区，请参考我的另一个文章制作一个空的 image 烧写 image 1gunzip -c kaylor.img.gz | dd of=/dev/xxx bs=20M 使用 parted 扩容分区 修改分区表 1sudo parted /dev/sdb 打印信息如下： 1234567891011121314151617181920212223242526272829GNU Parted 3.2Using /dev/sdbWelcome to GNU Parted! Type &apos;help&apos; to view a list of commands.(parted) pModel: Multiple Card Reader (scsi)Disk /dev/sdb: 15.8GBSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags:Number Start End Size Type File system Flags 1 154kB 52.4MB 52.3MB primary ext2 boot(parted) resizepart 1Warning: Partition /dev/sdb1 is being used. Are you sure you want to continue?Yes/No? YesEnd? [52.4MB]? 15.8G(parted) pModel: Multiple Card Reader (scsi)Disk /dev/sdb: 15.8GBSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags:Number Start End Size Type File system Flags 1 154kB 15.8GB 15.8GB primary ext2 boot(parted) qInformation: You may need to update /etc/fstab. 上述的指令可以复合成： 1sudo parted -s /dev/sdb resizepart 1 15.8G 恢复文件系统 1sudo e2fsck -f /dev/sdb1 扩容 1sudo resize2fs /dev/sdb1 APT 列出软件包可用版本 1apt-cache madison package-name 查看当前apt配置 1apt-config dump 这个指令可以过滤Install，设置一下apt默认的安装设置,比如123❯ cat /etc/apt/apt.conf.d/99user APT::Install-Recommends "0";APT::Install-Suggests "0"; 查看某个软件包的可用版本 12apt policy syslog-ngapt policy # 可以打印 123Package: *Pin: release a=ubuntu-updates # 可以是用apt policy获取相关信息Pin-Priority: 999 重新安装某个包的时候，询问是否覆盖配置文件1apt reinstall package -o Dpkg::Options::="--force-confask" GDB设置 设置ulimited 临时设置 12345❯ ulimit -c0❯ ulimit -c unlimited❯ ulimit -c unlimited 永久设置编辑/etc/security/limits.conf文件，在文件末尾添加 12* soft core unlimited* hard core unlimited 设置coredump文件格式和位置在/etc/sysctl.conf中添加 12kernel.core_pattern = ./core_%e_%t_%pkernel.core_uses_pid = 0 docker基本指令1234567docker ps -l #查看上一次运行的容器docker ps -a #查看历史运行的容器docker run -i -t ubuntu bash #运行ubuntu， -i表示标准输出， -t表示生成tty， bash是运行的指令docker inspecet 唯一ID或者容器名字 #返回容器的信息docker run --name=your_name -it ubuntu bash #定义容器的名字docker start -i container_name #重新启动停止的容器docker rm 容器的ID/容器名 #删除已经停止的容器 守护式容器1234567891011121314docker run -i -t ubuntu /bin/bash #启动之后使用Ctrl+P 和 Ctrl+Qdocker attach 容器ID/容器名 #重新进入退出的容器docker run -d CONTAINER [COMMAND] [argv ...] #后台启动容器，返回Docker守护进程分配的IDdocker logs [-f] [-t] [--tail] CONTAINER# -f --follow=true|false default:false# -t --timestamps=true|false default:false# --tail="all"docker top #查看运行情况docker exec [-d] [-t] [-t] CONTAINER_ID/NAME [COMMAND] [argv ...] #在运行的容器中启动新的进程docker stop CONTAINER_NAME/ID # 发送一个停止信号docker kill CONTAINER_NAME_ID # 直接停止容器 容器端口映射123456dodker run -P -i -t ubuntu /bin/bash #-P --publish-all=true|false default: falsedocker run -p 80 -i -t ubuntu /bin/bash # -p --publish=[] 指定端口docker run -p 8080:80 -i -t ubuntu /bin/bashdocker run -p 0.0.0.0:80 -i -t ubuntu /bin/bashdocker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bashdocker port CONTAINER_NAME/ID #查看端口映射情况 跨平台使用 docker运行特权容器 1docker run --rm --privileged docker/binfmt:66f9012c56a8316f9244ffd7622d7c21c1f6f28d 查看支持的 CPU 信息 1ls -al /proc/sys/fs/binfmt_misc/ 主机文件夹映射1docker run -it -v /home/kaylor/wifibroadcast/:/data --name rpi_env kaylor/rpi-env:20210507 /bin/bash 镜像1234567891011docker images [options] [repository]-a, --all=false #显示所有镜像，包括中间镜像-f, --filter=[]--no-trunc=false #不截断ID-q, --quiet=false #只显示IDdocker rmi [options] IMAGE-f, --force=false #强制删除--no-prune=false #保留未打标签的父镜像docker rmi $&#123;docker images -q ubuntu&#125; #删除ubuntu的所有镜像 查找 Images 从网站查找https://registry.hub.docker.com 使用命令 1234docker search [options] term #最多返回25个结果--automated=false--no-trunc-false-s, --stars=0 拉取 Images12docker pull [options] NAME[:TAG]-a, -all-tags=false 推送镜像1docker push repository 配置国内镜像地址编辑 /etc/docker/daemon.json 123&#123; &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 构建镜像12345678910111213docker commit #通过容器构建docker commit [options] CONTAINER [REPOSITORY[:TAG]]# -a, --author=""# -m, --message="" Commit message# -p, --pause=true Pause container during commitdocker build #通过Dockerfile文件构造docker build [options] PATH | URL | -# --force-rm=false# --no-cache=false# --pull=false# -q, -quiet=false# --rm=true# -t,--tag="" Doker 的 C/S 模式 Romote API unix:///var/run/docker.socktcp://host:portfd://socketfd Docker 的守护进程docker -d [options]-D, –debug=false-e, –exec-driver=”native”-g, –graph=”var/lib/docker”–icc=true-l, –log-level=”info”–lable=[]-p, –pidfile=””/var/run/docker.pid-G, –group=”docker”-H, –host=[]–tls=false–tlscacert=”/home/kaylor/.docker/ca.pem”–tlscert=”/home/kaylor/.docker/cert.pem”–tlskey=”/home/kaylor/.docker/key.pem”–tlsverify=falseRegistry 相关：–insecure-registry=[]–registry-mirror=[]网络相关:-b, –bridge=””–bip=””–fixed-cidr=””–fixed-cidr-v6=””–dns=[]–dns-search=[]–ip=0.0.0.0–ip-forward=true–ip-masq=true–iptables=true–ipv6=false–mtu=0 Docker 环境变量export DOCKER_HOST=”tcp://x.x.x.x:2375” 镜像保存与加载123docker save -o 要保存的文件名 要保存的镜像$ docker save -o test.tar ubuntudocker load --input 加载的文件名 dockerfile 指令Dockerfile 例子 12345FROM ubuntu:14.04MAINTAINER kaylor "kaylor@kaylordut.com"RUN apt updateRUN apt install -y vimEXPOSE 80 FROM 12FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt; 必须是 dockerfile 的第一条指令 MAINTAINER 1MAINTAINER &lt;name&gt; 包含作者和联系信息 RUN 123RUN &lt;command&gt;shell 模式： /bin/sh -c commandRUN echo hello 123RUN ["executalbe", "param1", "param2"]exec 模式：RUN ["/bin/bash", "-c", "echo hello"] EXPOSE 1EXPOSE &lt;port&gt; [&lt;port&gt;...] 虽然我们在镜像构建中指定了暴露的端口号，但在容器运行时，我们仍需要手动的指定容器的端口映射，就像我们之前曾经使用的这个 docker run 命令。也就是说，在 dockerfile 中使用 expose 指令来指定的端口，只是告诉 Docker，该容器内的应用程序会使用特定的端口儿，但是出于安全的考虑，Docker 并不会自动地打开端口，是需要在使用时再 run 命令中添加对端口的映射指令。 CMD 123CMD ["executalbe", "param1", "param2"]CMD command param1 param2CMD ["param1", "param2"] #作为ENTRYPOINT指令的默认参数 cmd 是指定容器运行时的默认指令，如果 docker run 带指令，会覆盖 cmd 的指令 ENTRYPOINT 12ENTRYPOINT ["executalbe", "param1", "param2"]ENTRYPOINT command param1 param2 docker run 的指令不能覆盖该指令。 ADD and COPY 12ADD/COPY src destADD/COPY ["src"..."dest"] #路径中有空格也可以使用 add 包含 tar 的解压缩功能，复制推荐使用 copy VOLUME WORKDIR ENV USER ONBUILD fswebcam 命令行拍照12345fswebcam -S 10 -r 640x480 --no-banner 1.jpg-S 跳过N帧-r 设置分辨率--no-banner 隐藏banner PVE 指令1qm stop ID #关机 exec， source 和 fork 的区别fork (/directory/script.sh) ：如果 shell 中包含执行命令，那么子命令并不影响父级的命令，在子命令执行完后再执行父级命令。子级的环境变量不会影响到父级。 fork 是最普通的, 就是直接在脚本里面用 /directory/script.sh 来调用 script.sh 这个脚本. 运行的时候开一个 sub-shell 执行调用的脚本， sub-shell 执行的时候, parent-shell 还在。sub-shell 执行完毕后返回 parent-shell 。 sub-shell 从 parent-shell 继承环境变量.但是 sub-shell 中的环境变量不会带回 parent-shell 。整个执行的过程是 fork + exec + waitpid (此三者均为系统调用)。 exec (exec /directory/script.sh) ：执行子级的命令后，不再执行父级命令。 exec 与 fork 不同，不需要新开一个 sub-shell 来执行被调用的脚本. 被调用的脚本与父脚本在同一个 shell 内执行。但是使用 exec 调用一个新脚本以后, 父脚本中 exec 行之后的内容就不会再执行了。这是 exec 和 source 的区别。 source (source /directory/script.sh) ：执行子级命令后继续执行父级命令，同时子级设置的环境变量会影响到父级的环境变量。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>docker</tag>
        <tag>Linux</tag>
        <tag>vim</tag>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode和Clion一般设置]]></title>
    <url>%2F2022%2F10%2F28%2FVSCode%E5%92%8CClion%E4%B8%80%E8%88%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[格式化代码 VSCode On Windows shift + alt + f //格式化整个文件 ctrl+k ctrl+f //格式化选中代码 On Linux ctrl + shift + i On MacOs shift + option + i //格式化整个文件 cmd+k cmd+f //格式化选中代码 Clion ctrl + alt + L 选择列编辑 Vscode alt + shift + 鼠标选择 Clion alt + 鼠标选择 VSCode头文件路径配置按下 ctrl + shift + P, 调用C/C++配置json文件，会在工程窗口生成 _c_cpp_properties.json_ , 可以使用原生的UI配置。 Doxygen函数注释 VSCode /** + 回车 Clion /*! + 回车 或者 /// + 回车 Clion快捷键更换runtime的时候，可以使用ctrl+shift+A，然后输入runtime]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译debian包相关]]></title>
    <url>%2F2022%2F08%2F07%2FDebian%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[安装基础软件包1apt install devscripts equivs 开启deb-src选项比如需要再focal上编译jammy的源码，可以假如jammy的源码选项12345$ cat /etc/apt/sources.list.d/jammy-source.list ─╯deb-src https://mirrors.cloud.tencent.com/ubuntu/ jammy universe main restricted multiverse #Added by software-propertiesdeb-src https://mirrors.cloud.tencent.com/ubuntu/ jammy-updates universe main restricted multiverse #Added by software-propertiesdeb-src https://mirrors.cloud.tencent.com/ubuntu/ jammy-backports main restricted universe multiverse #Added by software-propertiesdeb-src https://mirrors.cloud.tencent.com/ubuntu/ jammy-security universe main restricted multiverse #Added by software-properties 获取源码安装编译依赖假设需要编译vim12345apt showsrc vimapt source vimapt build-dep vim# ormk-build-deps debian/control --install --remove 编译相关包12345fakeroot debian/rules binaryfakeroot debian/rules cleanDEB_BUILD_OPTIONS=&quot;parallel=7 nocheck&quot; fakeroot debian/rules binary # 使用7个线程编译，编译过程不测试代码# ordpkg-buildpackage -j -us -uc -aarm64 -b]]></content>
      <categories>
        <category>Debian</category>
      </categories>
      <tags>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS常用设置]]></title>
    <url>%2F2022%2F08%2F07%2FROS%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ROS1安装ROS1如果是在深圳，推荐使用腾讯的官方源，该教程默认安装noetic版本的ROS 1234567sudo sh -c 'echo "deb https://mirrors.tencent.com/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'sudo apt install curlcurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -sudo apt updatesudo apt install ros-noetic-ros-base python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essentialsudo rosdep initrosdep update ROS主从机配置ros的主从机只需要配置ROS_IP和ROS_MASTER_URI就可以。主机配置的ROS_IP是主机的局域网的IP， ROS_MASTER_URI是应该是使用局域网的IP加端口，如 ROS_MASTER_URI=“http://192.168.23.10:11311”，如果主机端没有配置ROS_IP，那么主机的xmlrpc会直接返回hostname，这时候如果从机并不知道该hostname是对应什么IP，这样从机就无法建立有效链接。如果不想配置死环境变量，可以使用roslaunch对针对性应用配置临时环境变量，比如： 123456&lt;launch&gt;&lt;node pkg="rviz" type="rviz" name="rviz" &gt; &lt;env name="ROS_IP" value="192.168.23.100" /&gt; &lt;env name="ROS_MASTER_URI" value="http://192.168.23.10:11311" /&gt;&lt;/node&gt;&lt;/launch&gt; 切记，ROS_MASTER_URI就是局域网内主机的IP，两侧机器是一样的。但是ROS_IP是各自主机的IP。一切配hostname的教程都是大忽悠！！！！ 编译相关123rosdep install --from-paths src --ignore-src -r -y #根据package.xml安装依赖catkin_make install -DCATKIN_WHITELIST_PACKAGES="clean_robot_base;ultrasonic;tof_pointcloud" -DCMAKE_BUILD_TYPE=Debugcatkin_create_pkg 包名 依赖1 依赖2 ... 有时候为了方便，也可以编辑Makefile，添加一下特定的环境变量 12345678ARCH = $(shell arch)all: @echo CPU ARCH is $&#123;ARCH&#125; catkin_make install -DCATKIN_WHITELIST_PACKAGES="clean_robot_base;ultrasonic;tof_pointcloud" \ -DCMAKE_BUILD_TYPE=Release \ -DCATKIN_DEVEL_PREFIX=./devel_$&#123;ARCH&#125; \ -DCMAKE_INSTALL_PREFIX=./install_$&#123;ARCH&#125; \ --build ./build_$&#123;ARCH&#125; CMakeLists.txt的install选项123456789101112131415161718192021222324252627# 安装可执行文件install(TARGETS $&#123;PROJECT_NAME&#125;_node RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)# 安装用户动态库install(TARGETS $&#123;PROJECT_NAME&#125; ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125; LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125; RUNTIME DESTINATION $&#123;CATKIN_GLOBAL_BIN_DESTINATION&#125;)# 安装文件install(FILES myfile1 myfile2 DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;)# 安装文件夹install(DIRECTORY launch DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125; PATTERN ".svn" EXCLUDE)install(DIRECTORY paramsDESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;PATTERN ".svn" EXCLUDE) 安装部署ROS提供了一个robot_upstart的特殊节点作为安装服务。我们先看一下robot_upstart的用法：12345678910111213141516171819202122232425262728&gt; rosrun robot_upstart install -husage: install [-h] [--job JOB] [--interface ethN] [--user NAME] [--setup path/to/setup.bash] [--rosdistro DISTRO] [--master http://MASTER:11311] [--logdir path/to/logs] [--augment] [--provider [upstart|systemd]] [--symlink] [--wait] [--systemd-after After=] pkg/path [pkg/path ...]Use this tool to quickly and easily create system startup jobs which run one or more ROS launch files as a daemonized background process on your computer.More advanced users will prefer to access the Python API from their own setup scripts, but this exists as a simple helper, an example, and a compatibilityshim for previous versions of robot_upstart which were bash-based.positional arguments: pkg/path 包名/需要安装的launch文件路劲，比如包名是test，launch文件路径是launch/test.launch，那么这个选项就是test/launch/test.launch optional arguments: -h, --help show this help message and exit --job JOB 给服务取一个指定的名字，可以不设置 --interface ethN Specify network interface name to associate job with. --user NAME Specify user to launch job as. --setup path/to/setup.bash 这里是指向一个包的setup.bash路径，为了避免不必要的麻烦，使用绝对路径 --rosdistro DISTRO Specify ROS distro this is for. --master http://MASTER:11311 Specify an alternative ROS_MASTER_URI for the job launch context. --logdir path/to/logs Specify an a value for ROS_LOG_DIR in the job launch context. --augment Bypass creating the job, and only copy user files. Assumes the job was previously created. --provider [upstart|systemd] Specify provider if the autodetect fails to identify the correct provider --symlink 不复制launch文件，使用软链接指向包的launch文件 --wait Pass a wait flag to roslaunch. --systemd-after test.service 设置这个服务在test.service之后启动 参考指令1rosrun robot_upstart install --job kaylor --setup $(pwd)/install/setup.bash --systemd-after "test.service network.target" test/launch/talker.launch 上面的指令，注意setup.bash一定是bash！！！如果需要加入环境变量，可以自己添加一个.bash文件，设置环境变量之后，再source这个ros的setup.bash。当然，也可以通过修改service文件引入环境变量 ROS2安装ROS2 Humble安装官方通用通用源(这里使用腾讯的镜像源)12sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://mirrors.cloud.tencent.com/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null 如果你的系统是ubuntu20.04，仍然想使用humble，做如下设置：12sudo curl -sSL http://apt.kaylordut.cn/kaylor-keyring.gpg -o /usr/share/keyrings/kaylor-keyring.gpgecho "deb [signed-by=/usr/share/keyrings/kaylor-keyring.gpg] http://apt.kaylordut.cn/ros2/ubuntu/ focal main" | sudo tee /etc/apt/sources.list.d/kaylor-ros2.list &gt; /dev/null 最后，安装你需要的版本：12345sudo apt updatesudo apt upgradesudo apt install ros-humble-desktopsudo apt install ros-humble-ros-basesudo apt install ros-dev-tools 如果你需要的安装包找不到，请邮件到kaylor.chen@qq.com，我会抽空做好适配 常用代码只订阅一次topic12msg_type tmp;bool ret = rclcpp::wait_for_message(tmp, this-&gt;shared_from_this(), topic_name, std::chrono::seconds(3)); 注意，这个方法不能在自身构造函数里使用，所以一般可以写成成员函数调用。 常用指令 创建包 1ros2 pkg create --build-type ament_cmake --dependencies geometry_msgs rclcpp tf2 tf2_ros turtlesim -- learning_tf2_cpp 安装依赖包 1rosdep install -i --from-path src --rosdistro foxy -y 编译相关cmake 设置相关123456789101112131415# Install launch files.install(DIRECTORY launch DESTINATION share/$&#123;PROJECT_NAME&#125;/)# Install parameters files.install(DIRECTORY params DESTINATION share/$&#123;PROJECT_NAME&#125;/)install(TARGETSclean_robot_base DESTINATION lib/$&#123;PROJECT_NAME&#125;) 添加依赖选项 第一，需要在package.xml里添加tf2_geometry_msgs 第二，在cmake里添加12find_package(tf2_geometry_msgs REQUIRED)ament_target_dependencies(target tf2_geometry_msgs) colcon build 使用symlink选项，install文件夹的文件生成软连接，否则生成的是拷贝 1colcon build --symlink-install 编译指定的包 1colcon build --packages-select package_name 编译指定的包和它的依赖 1colcon build --packages-up-to package_name 编译时忽略的包 1colcon build --packages-ignore package_name 编译的时候添加cmake参数选项 1colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug/Release 编译一个package 并且把log 显示在屏幕上 1colcon build --packages-select rmw_coredds_shared_cpp --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Debug --event-handlers=console_direct+ 编译之前构建失败的包，不包括先前已经中止的包 1colcon build --packages-select-build-failed 跳过之前之前已经完成构建的包 1colcon build --packages-skip-build-finished 指定编译的build base 1colcon build --build-base path 指定安装目录 1colcon build --install-base path 并行编译参数 1colcon build --parallel-worker Number 安装不添加子目录 1colcon build --merge-install 部署 安装robot-upstart包 source自己的包的setup.bash 这里的目的是为了下一步的运行的指令能找到要安装的包 添加启动任务12# 举例说明ros2 run robot_upstart install --job test --setup your_package_setup.bash_path your_package_name/launch/test.launch.py --logdir logdir_path 注意那个launch文件的命名一定要launch.py结尾，不然启动到时候会有问题。–setup选项需要的是一个路径，但是后面的launch文件路径是需要“包名/launch/launch文件名”如果ROS需要操作一些外设，可能存在权限问题，这时候生成启动任务的指令，最好在root用户下进行]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[功率MOS知识点总结]]></title>
    <url>%2F2022%2F08%2F07%2F%E5%8A%9F%E7%8E%87MOS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[功耗和电流本文参考Nexperia的AN11158应用手册计算，链接在这里 估算不同温度的$I_{d}$$$P=I^{2} \times R_{DS_{on}}$$器件在结温的时候的耗散功率，这里假定${R_{DS_{on}}}$ 恒定且是最高结温的时候的导通电阻。有 $$I_{d}^{2}(T_{mb})\propto \frac{T_{j}-T_{mb}}{T_{j}-25^\circ C}$$ $$I_{d}(T_{mb})= I_{d}(25^\circ C)\times \sqrt{\frac{T_{j}-T_{mb}}{T_{j}-25^\circ C}}$$ 耗散功率某个温度的耗散功率比如，根据数据手册$25^\circ C$的时候的最大耗散功率是105W，那么$75^\circ C$的耗散功率等于： $$P_{tot}(75)=P_{tot}(25)\times \frac{T_{j}-75}{T_{j}-25}=105 \times \frac{175-75}{175-25}=70 W $$ 从温升计算最大功耗和电流从数据手册中可以得到结到壳的热阻是 $1.3^\circ C/W$ , 壳温是25度，结温是175的时候，耗散功率是150/1.3=115.38W，这时候可以看到数据手册写的是115W。从数据手册中可以查到结温是175的时候，导通电阻是6.7 $m\Omega$。 $$I_{max}=\sqrt{\frac{115.38W}{0.0067 \Omega } } = 131.23A$$ 这里需要注意，虽然计算是131A，但是根据数据手册描述，其他限制了这个MOS的能力，所以降额到了120A。]]></content>
      <categories>
        <category>电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clion配置STM32开发环境的一些注意细节]]></title>
    <url>%2F2022%2F07%2F28%2FClion%E9%85%8D%E7%BD%AESTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[使用newlib库cmake里面加12add_compile_options(--specs=nano.specs)add_link_options(--specs=nosys.specs --specs=nano.specs -Wl,--start-group -lc -lm -Wl,--end-group) 启用硬浮点编译1234567#Uncomment for hardware floating pointadd_compile_definitions(ARM_MATH_CM4;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING)add_compile_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16)add_link_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16)#Uncomment for software floating point#add_compile_options(-mfloat-abi=soft) 启用浮点打印1add_link_options(-u _printf_float)]]></content>
      <categories>
        <category>Embedded</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>CLion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学公式]]></title>
    <url>%2F2021%2F08%2F20%2F%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[三角函数同角三角函数的基本关系$$\tan\alpha\cdot\cot\alpha=1$$$$\sin\alpha\cdot\csc\alpha=1$$$$\cos\alpha\cdot\sec\alpha=1$$$$\frac{\sin\alpha}{\cos\alpha}=\tan\alpha=\frac{\sec\alpha}{\csc\alpha}$$$$\frac{\cos\alpha}{\sin\alpha}=\cot\alpha=\frac{\csc\alpha}{\sec\alpha}$$$$\sin^2\alpha+\cos^2\alpha=1$$$$1+\tan^2\alpha=\sec^2\alpha$$$$1+\cot^2\alpha=\csc^2\alpha$$ 诱导公式$$\sin(-\alpha)=-\sin\alpha$$$$\cos(-\alpha)=\cos\alpha$$$$\tan(-\alpha)=-\tan\alpha$$$$\cot(-\alpha)=-\cot\alpha$$\begin{array}{c|c|c}\frac\pi2-\alpha &amp; \frac\pi2+\alpha &amp; \pi-\alpha \\\hline{\sin(\frac\pi2-\alpha)=\cos\alpha \\ \cos(\frac\pi2-\alpha)=\sin\alpha \\ \tan(\frac\pi2-\alpha)=\cot\alpha \\ \cot(\frac\pi2-\alpha)=\tan\alpha} &amp;{\sin(\frac\pi2+\alpha)=\cos\alpha \\ \cos(\frac\pi2+\alpha)=-\sin\alpha \\ \tan(\frac\pi2+\alpha)=-\cot\alpha \\ \cot(\frac\pi2+\alpha)=-\tan\alpha}&amp;{\sin(\pi-\alpha)=\sin\alpha \\ \cos(\pi-\alpha)=-\cos\alpha \\ \tan(\pi-\alpha)=-\tan\alpha \\ \cot(\pi-\alpha)=-\cot\alpha}\end{array}\begin{array}{c|c|c}\pi+\alpha &amp; \frac{3\pi}{2}-\alpha &amp; \frac{3\pi}{2}+\alpha\\\hline{\sin(\pi+\alpha)=-\sin\alpha \\ \cos(\pi+\alpha)=-\cos\alpha \\ \tan(\pi+\alpha)=\tan\alpha \\ \cot(\pi+\alpha)=\cot\alpha}&amp;{\sin(\frac{3\pi}{2}-\alpha)=-\cos\alpha \\ \cos(\frac{3\pi}{2}-\alpha)=-\sin\alpha \\ \tan(\frac{3\pi}{2}-\alpha)=\cot\alpha \\ \cot(\frac{3\pi}{2}-\alpha)=\tan\alpha}&amp;{\sin(\frac{3\pi}{2}+\alpha)=-\cos\alpha \\ \cos(\frac{3\pi}{2}+\alpha)=\sin\alpha \\ \tan(\frac{3\pi}{2}+\alpha)=-\cot\alpha \\ \cot(\frac{3\pi}{2}+\alpha)=-\tan\alpha}\end{array} 两角和与差的三角函数公式$$\left. \begin{aligned} &amp;\sin(\alpha\pm\beta)=\sin\alpha\cos\beta\pm\cos\alpha\sin\beta \\ &amp;\cos(\alpha\pm\beta)=\cos\alpha\cos\beta\mp\sin\alpha\sin\beta \\ &amp;\tan(\alpha\pm\beta)=\frac{\tan\alpha\pm\tan\beta}{1-\tan\alpha\cdot\tan\beta} \end{aligned} \right.$$ 万能公式$$\left. \begin{aligned} &amp;\sin\alpha=\frac{2\tan(\alpha/2)}{1+\tan^2(\alpha/2)} \\ &amp;\cos\alpha=\frac{1-\tan^2(\alpha/2)}{1+\tan^2(\alpha/2)} \\ &amp;\tan\alpha=\frac{2\tan(\alpha/2)}{1-\tan^2(\alpha/2)} \end{aligned} \right.$$ 半角公式$$\left. \begin{aligned} &amp;\sin\left(\frac{\alpha}{2}\right)=\pm\sqrt{\frac{1-\cos\alpha}{2}} \\ &amp;\cos\left(\frac{\alpha}{2}\right)=\pm\sqrt{\frac{1+\cos\alpha}{2}} \\ &amp;\tan\left(\frac{\alpha}{2}\right)=\pm\sqrt{\frac{1-\cos\alpha}{1+\cos\alpha}}=\frac{1-\cos\alpha}{\sin\alpha}=\frac{\sin\alpha}{1+\cos\alpha} \end{aligned} \right.$$ 降幂公式$$\left. \begin{aligned} &amp;\sin^2\alpha=\frac{1-\cos2\alpha}{2} \\ &amp;\cos^2\alpha=\frac{1+\cos2\alpha}{2} \end{aligned} \right.$$ 二倍角公式$$\left. \begin{aligned} &amp;\sin2\alpha=2\sin\alpha\cos\alpha \\ &amp;\cos2\alpha=\cos^2\alpha-\sin^2\alpha=2\cos^2\alpha-1=1-2\sin^2\alpha=\frac{1-\tan^2\alpha}{1+\tan^2\alpha} \\ &amp;\tan2\alpha=\frac{2\tan\alpha}{1-\tan^2\alpha}=\frac{2\cot\alpha}{\cot^2\alpha-1}=\frac{2}{\cot\alpha-\tan\alpha} \\ &amp;\cot2\alpha=\frac{\cot^2\alpha-1}{2\cot\alpha}=\frac{1-\tan^2\alpha}{2\tan\alpha}=\frac{\cot\alpha-\tan\alpha}{2} \end{aligned} \right.$$ 三倍角公式$$\left. \begin{aligned} &amp;\sin3\alpha=3\sin\alpha-4\sin^3\alpha \\ &amp;\cos3\alpha=-3\cos\alpha+4\cos^3\alpha \\ &amp;\tan3\alpha=\frac{3\tan\alpha-\tan^3\alpha}{1-3\tan^2\alpha}=\tan\alpha\tan\left(\frac\pi3+\alpha\right)\tan\left(\frac\pi3-\alpha\right) \\ &amp;\cot3\alpha=\frac{3\cot\alpha-\cot^3\alpha}{1-3\cot^2\alpha} \end{aligned} \right.$$ 和差化积公式$$\left. \begin{aligned} &amp;\sin\alpha+\sin\beta=2\sin\frac{\alpha+\beta}{2}\cdot\cos\frac{\alpha-\beta}{2} \\ &amp;\sin\alpha-\sin\beta=\sin\alpha+\sin(-\beta)=2\cos\frac{\alpha+\beta}{2}\cdot\sin\frac{\alpha-\beta}{2} \\ &amp;\cos\alpha+\cos\beta=2\cos\frac{\alpha+\beta}{2}\cdot\cos\frac{\alpha-\beta}{2} \\ &amp;\cos\alpha-\cos\beta=-2\sin\frac{\alpha+\beta}{2}\cdot\sin\frac{\alpha-\beta}{2} \end{aligned} \right.$$ 积化和差公式$$\left. \begin{aligned} &amp;\sin\alpha\cdot\cos\beta=\frac12[\sin(\alpha+\beta)+\sin(\alpha-\beta)] \\ &amp;\cos\alpha\cdot\sin\beta=\frac12[\sin(\alpha+\beta)+\sin(\beta-\alpha)]=\frac12[\sin(\alpha+\beta)-\sin(\alpha-\beta)] \\ &amp;\cos\alpha\cdot\cos\beta=\frac12[\cos(\alpha+\beta)+\cos(\alpha-\beta)] \\ &amp;\sin\alpha\cdot\sin\beta=-\frac12[\cos(\alpha+\beta)-\cos(\alpha-\beta)] \end{aligned} \right.$$ 辅助角的三角函数公式$$a\sin x+b\cos x=\sqrt{a^2+b^2}\sin(x+\arctan\frac ba)$$]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用配置]]></title>
    <url>%2F2021%2F08%2F07%2FDocker%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装docker卸载旧版本1sudo apt-get remove docker docker-engine docker.io containerd runc 安装新版本 设置仓库源 更新apt包索引，安装依赖 12sudo apt-get updatesudo apt-get install ca-certificates curl gnupg lsb-release 添加docker官方GPG key 12sudo mkdir -p /etc/apt/keyringscurl -fsSL https://mirrors.huaweicloud.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 设置仓库源 123echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu \$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 安装docker引擎 安装最新版本 12sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin 至此，你已经完成了docker最新稳定版本的安装！！！ 选择安装指定版本 123456789101. 列出可用版本$ apt-cache madison docker-ce | awk '&#123; print $3 &#125;'5:20.10.16~3-0~ubuntu-jammy5:20.10.15~3-0~ubuntu-jammy5:20.10.14~3-0~ubuntu-jammy5:20.10.13~3-0~ubuntu-jammy2. 安装指定版本$ VERSION_STRING=5:20.10.13~3-0~ubuntu-jammy$ sudo apt-get install docker-ce=$VERSION_STRING docker-ce-cli=$VERSION_STRING containerd.io docker-compose-plugin 设置非root用户不使用sudo123usermod -a -G docker usernamenewgrp docker # 及时生效reboot 一些基本指令合并不同平台容器到同一个tag12docker manifest create image:tag image1:tag1 image2:tag2docker manifest push image:tag 拉取镜像1docker pull ubuntu:20.04 从远程拉取名仓库为ubuntu的，tag为20.04的镜像到本地 运行容器我们前面已经拉取了一个ubuntu 20.04的基础容器，现在我们可以试着运行这个容器。进入容器并执行bash命令。 1docker run --name=network_test --net=host -it ubuntu:20.04 bash –name 给即将运行的容器命名一个别名 –net 这个参数默认是使用doker的内置网桥，这里使用host说明容器直接使用主机网络 -it 这里-i表示标准输出，-t表示生成tty bash 是表示进入容器之后需要运行的指令 重新运行容器实际操作里面，我们时常想重新进入容器。比如 123╰─ docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe977e612b806 ubuntu:20.04 "bash" 41 minutes ago Exited (0) 2 minutes ago network_test 从上面的信息看到，这个容器执行指令bash，在2分钟之前退出了。可是使用以下指令重启容器 123docker start network_test或者docker start e977e612b806 容器启动之后，我们可以使用docker attach指令重新进入终端,如： 1docker attach network_test 但是，有时候可能需要加入多个终端，所以可以使用docker exec来实现 1docker exec -it network_test bash 文件夹映射在实际的开发过程中，我们经常需要共享主机和docker的文件。所以我们可以把主机某些文件夹映射到docker的目录下 1docker run -it -v /opt/kaylor/:/root/data/ --name=map_test ubuntu:20.04 bash -v 主机文件夹路径：docker的文件夹映射路径 保存与加载1docker save -o rk3588_docker.tar kaylor/rk3588_dev_env:latest 将本机的名为kaylor/rk3588_dev_env，tag为latest的镜像保存输出为rk3588_docker.tar 1docker load --input rk3588_docker.tar 这里注意，加载的tar包需要时通过docker save保存的，通过docker save的镜像会带有原始的提交信息。 构建镜像通常我们会在容器中添加了我们的一些自定义的操作，我们可以通过构建镜像的方式，把容器保存成镜像。比如： 123docker container ps -a ##查看所有容器的信息CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES05cd5820058b deb7cc07afe8 "/bin/bash" 2 months ago Exited (0) 2 weeks ago musing_aryabhata 上面的命令我们知道容器的ID是05cd5820058b，下面的命令是将这个容器提交生成image-a 是添加作者信息-m 是添加commit的信息kaylor/rk3588_dev_env:v1 镜像名为kaylor/rk3588_dev_env tag为v1 1docker commit -a "kaylorchen" -m "add libsystemd-dev" 05cd5820058b kaylor/rk3588_dev_env:v1 使用主机GPU 查看 -gpus 参数是否安装成功 1docker run --help | grep -i gpus 运行容器 12docker run --gpus all --name container_name -d -t image_iddocker run --gpus="1" images_id 创建自定义子网使用固定IP12docker network create --subnet=192.168.77.0/24 kaylor_bridgedocker run -d --name kaylor --net kaylor_bridge --ip 192.168.77.2 ubuntu:22.04 跨平台使用 使用特权容器 windows和mac使用的是桌面版，默认已经启动了binfmt_misc, 我们使用的是Linux，可以手动启动该功能，但是我们有更好的方法，就是启动一个特权容器，指令如下： 1docker run --rm --privileged docker/binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64 使用指令ls -al /proc/sys/fs/binfmt_misc，看看是否有qemu字样的输出。使用 docker buildx ls查看构建器支持的CPU架构。 安装qemu包 1sudo apt install qemu-user-static 构建树莓派交叉编译镜像123456789101112131415#下载官方镜像wget https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2021-05-28/2021-05-07-raspios-buster-armhf-lite.zipunzip 2021-05-07-raspios-buster-armhf-lite.zipfdisk -l 2021-05-07-raspios-buster-armhf-lite.img #这里是使用fdisk查看分区信息，mount指令需要使用mkdir imagesudo mount -o loop,offset=$((512*532480)) 2021-05-07-raspios-buster-armhf-lite.img image/sudo apt install qemu-user-static -ysudo mv image/etc/ld.so.preload image/etc/ld.so.preload.baksudo cp /usr/bin/qemu-arm-static image/usr/bin/cd image/sudo tar cvf ../rpi-env-2021-05-07.tar .cd ..umount imagedocker import rpi-env-2021-05-07.tar rpi-env:20210507docker run -it rpi-env:20210507 /bin/bash 退出容器之后，可以使用docker start ID 和 docker attach ID 重新进入我已经设置好了基础仓库，可以直接使用docker pull kaylor/rpi-env拉取 共享宿主机文件夹/home/kaylor/aaa –&gt; /share 1docker run -it -v /home/kaylor/aaa:/share kaylor/rpi-env:20210507 /bin/bash 从根文件系统构建docker镜像参考链接 https://docs.docker.com/engine/reference/commandline/import/ 12cd rootfs_pathsudo tar -c . | docker import - docker_name]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Create a Blank Image]]></title>
    <url>%2F2021%2F08%2F07%2F%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84image%2F</url>
    <content type="text"><![CDATA[Shell script1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/bin/bashstart=8192middle=532479 # start ~ middle is 256MBytes, this is boot partition# end=6291456 end=614400total_size=$(expr $end \/ 2048) #Unit is MBytesecho total size is $total_size MBytesecho "Deleting old image"sudo rm $&#123;total_size&#125;MB -recho "Unmounting everything that could be mounted"sudo umount * &gt; /dev/null 2&gt;&amp;1sudo losetup -d /dev/loop101 &gt; /dev/null 2&gt;&amp;1echo "Recreating mount points"mkdir rootfsmkdir bootecho "Creating empty file"dd if=/dev/zero of=disk.img bs=1M count=$total_sizeecho "Associating loopback device to image"sudo losetup /dev/loop101 disk.imgecho "Partitioning image"sudo parted -s /dev/loop101 mklabel msdossudo parted -a none -s /dev/loop101 unit s mkpart primary fat32 $start $middlesudo parted -a none -s /dev/loop101 unit s mkpart primary ext4 $(expr $middle \+ 1) $( expr $end \- 1)echo "Setting partition as bootable"sudo parted /dev/loop101 set 1 boot onsudo mkfs.vfat -F 32 /dev/loop101p1 # "-F 32" is fat32sudo mkfs.ext4 /dev/loop101p2echo "Adding label to partition :"sudo fatlabel /dev/loop101p1 boot # this partition is fat32 fssudo e2label /dev/loop101p2 rootfsecho "Mounting disk image"sudo mount /dev/loop101p1 bootsudo mount /dev/loop101p2 rootfssudo blkid | grep loop101# ROOT=root=PARTUUID=$(sudo blkid | grep loop100p1 | sed -e 's/ /\n/g' |grep PARTUUID | awk -F '\"' '&#123;print $2&#125;')# echo ROOT=$ROOT# sudo sed -i -e 's/root=\/dev\/mmcblk0p1/'$&#123;ROOT&#125;'/g' mnt/boot/grub/grub.cfgecho "Unmounting files"sudo umount rootfssudo umount bootsudo losetup -d /dev/loop101echo "gzip disk.img"ls -l |grep disk.imgfdisk -l disk.imgparted disk.img printsudo gzip disk.imgls -l |grep disk.imgecho "rename disk.img.gz to blank_image.img.gz"mv disk.img.gz blank_image.img.gzmkdir $&#123;total_size&#125;MBmv blank_image.img.gz $&#123;total_size&#125;MBecho "Deleting temporary files"sudo rm -rf rootfssudo rm -rf boot]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>parted</tag>
        <tag>fdisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用matlab标定相机参数和畸变系数]]></title>
    <url>%2F2020%2F07%2F11%2F%E4%BD%BF%E7%94%A8matlab%E6%A0%87%E5%AE%9A%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E5%92%8C%E7%95%B8%E5%8F%98%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[打开摄像头校准APP 加载校准图片并设置实际方格大小加载图片之后，对比每张图片，把原点识别出错的图片移除 校准并输出参数 查看校准的相机参数和畸变系数]]></content>
      <categories>
        <category>Computer Vison</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用live555低延时直播USB摄像头视频流]]></title>
    <url>%2F2020%2F05%2F19%2F%E4%BD%BF%E7%94%A8live555%E4%BD%8E%E5%BB%B6%E6%97%B6%E7%9B%B4%E6%92%ADUSB%E6%91%84%E5%83%8F%E5%A4%B4%E8%A7%86%E9%A2%91%E6%B5%81%2F</url>
    <content type="text"><![CDATA[背景分析了live555的源码，其中的样例多数时从文件读取H264文件进行直播，没有直接从摄像头读取视频流直接编码实现的样例。根据自己需求，按照live555的样例实现了几个类。 具体实现源码从我的github直接获取：github客户端接收可以使用VLC，也可以使用我的另外一个代码（有bug，显示没有问题）.VLC需要设置缓存，导致了较大的延时，我的代码只是直接获取每一帧直接解码，这样的实时性根据我的测试，在局域网的640*480的分辨率下，可以到达140ms的延时，平均带宽2Mbit/s.]]></content>
      <categories>
        <category>Network</category>
        <category>RTSP</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>RTSP</tag>
        <tag>live555</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to setup a second order C++ IIR filter with Matlab]]></title>
    <url>%2F2019%2F08%2F08%2FHow-to-setup-a-second-order-C-IIR-filter-with-Matlab%2F</url>
    <content type="text"><![CDATA[Generating parameters with MatlabOpen your matlab and type fdatool, and click “Analysis-&gt;Filter Coefficients“.Click “Design Filter“ and get filter parameters.Numerator: [ 1 2 1 ]Denominator: [ 1 -1.8153410827045682 0.83100558934675761 ]Gain: 0.0039161266605473692 Test your IIR filtergit IIR Code1git clone https://github.com/kaylorchen/IIR_Filter.git Initialize your filter:1IIR_Filter lowpass(1, 2, 1, -1.8153410827045682, 0.83100558934675761); // Fs = 48000, Fc=1000]]></content>
      <categories>
        <category>Robot</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>Filter</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何把你的4G变成你家的WiFi]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BD%A0%E7%9A%844G%E5%8F%98%E6%88%90%E4%BD%A0%E5%AE%B6%E7%9A%84WiFi%2F</url>
    <content type="text"><![CDATA[前言在流量多如牛毛的今天，某宝随意开个19块钱就能100G流量的今天，装个宽带居然还要个100+ RMB。我们穷苦的孩子用不起高大上的宽带，现在搞个4G改WiFi还是可行的。 硬件准备 带USB口的路由器，能刷固件（最好是OpenWrt） USB接口的车载4G Dongle, 如华为的e8278s-602。（本人用的是这个，理论上任何的4G Dongle都可行） 增益天线，比如某宝的：https://item.taobao.com/item.htm?spm=a1z1r.7974869.0.0.269c3ad4mtnUJW&amp;id=563132470233 带有大流量套餐的SIM卡 路由配置 给4G dongle装好SIM卡，使用PC确认其能上网 把4G dongle装好天线，并插到路由器的USB口上 打开路由器管理界面并登陆，如192.168.111.1 （我默认路由系统已经被你刷好） 打开选项卡 网络 -&gt; 接口, 然后添加接口，“新接口名称”可以随意设置，“新接口协议”如果不懂静态IP知识的，可以选择“DHCP客户端”，“包括以下接口”一定要选择4G Dongle的接口。（如果不知道接口的话，在不提交的前提下插拔USB测试接口） 上一步完成之后，编辑你的接口，把防火墙设置分配到“WAN” 如果一切都顺利，那你就可以测试你的网络了~]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add rc.local Service for Ubuntu 18.04]]></title>
    <url>%2F2019%2F06%2F25%2FAdd-rc-local-Service-for-Ubuntu-18-04%2F</url>
    <content type="text"><![CDATA[Modify /lib/systemd/system/rc-local.serviceAppend some content:12345678910111213141516[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no[Install]WantedBy=multi-user.targetAlias=rc-local.service Configure /etc/rc.local12touch /etc/rc.localchmod 755 /etc/rc.local Edit /etc/rc.local, and the content is as follows:12#!/bin/bashecho &quot;test rc &quot; &gt; /var/test.log Reboot your OS, and check /var/test.log.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP32 Configure WiFi and Control LED Frequency and duty via WebSever]]></title>
    <url>%2F2019%2F05%2F27%2FESP32-Configure-WiFi-and-Control-LED-Frequency-and-duty-via-WebSever%2F</url>
    <content type="text"><![CDATA[Video If you can’t open this Youtube link, please click this.]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Setup a SoftAP with Raspberry Pi]]></title>
    <url>%2F2019%2F05%2F22%2FSetup-a-SoftAP-with-Raspberry-Pi%2F</url>
    <content type="text"><![CDATA[Install hostapd and dnsmasq1sudo apt install hostapd dnsmasq ConfigurationEdit dhcpcd.confEdit /etc/dhcpcd.conf and append a new line: denyinterfaces wlan0. Edit interfacesEdit /etc/network/interfaces.d/wlan0, and the content is as follows:1234allow-hotplug wlan0iface wlan0 inet staticaddress 192.168.77.77netmask 255.255.255.0 Restart dhcpcd service123sudo service dhcpcd restartsudo ifdown wlan0sudo ifup wlan0 Configure hostapdEdit /etc/hostapd/hostapd.conf, and the contend is as follows:123456789101112131415161718192021222324252627282930# This is the name of the WiFi interface we configured aboveinterface=wlan0# Use the nl80211 driver with the brcmfmac driverdriver=nl80211# This is the name of the networkssid=Pi3-AP# Use the 2.4GHz bandhw_mode=g# Use channel 6channel=6# Enable 802.11nieee80211n=1# Enable WMMwmm_enabled=1# Enable 40MHz channels with 20ns guard intervalht_capab=[HT40][SHORT-GI-20][DSSS_CCK-40]# Accept all MAC addressesmacaddr_acl=0# Use WPA authenticationauth_algs=1# Require clients to know the network nameignore_broadcast_ssid=0# Use WPA2wpa=2# Use a pre-shared keywpa_key_mgmt=WPA-PSK# The network passphrasewpa_passphrase=raspberry# Use AES, instead of TKIPrsn_pairwise=CCMP Edit /etc/default/hostapd, and append a new line: DAEMON_CONF=”/etc/hostapd/hostapd.conf”Test: sudo hostapd /etc/hostapd/hostapd.conf]]></content>
      <categories>
        <category>Network</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>hostapd</tag>
        <tag>dnsmasq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT Client for ESP32]]></title>
    <url>%2F2019%2F05%2F08%2FMQTT-Client-for-ESP32%2F</url>
    <content type="text"><![CDATA[Requirements Publish a message from ESP32 Subscribe a topic SoftwareDownload MQTT Client Opensource CodeClone source code from https://github.com/knolleary/pubsubclient.git.Copy PubSubClient.cpp and PubSubClient.h from the original src/ to your ESP32 project’s src/. Program Yourself Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;Arduino.h&gt;#include "WiFi.h"#include "PubSubClient.h"// Update these with values suitable for your network.#define BUILTIN_LED 2const char* ssid = "Xiaomi_kaylordut";const char* password = "kaylordut.com";const char* mqtt_server = "your.mqtt.server.address";const int mqtt_port = 11111;const char* mqtt_user = "username";const char* mqtt_passwd = "password";WiFiClient espClient;PubSubClient client(espClient);long lastMsg = 0;char msg[50];int value = 0;void setup_wifi() &#123; delay(10); // We start by connecting to a WiFi network Serial.println(); Serial.print("Connecting to "); Serial.println(ssid); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print("."); &#125; randomSeed(micros()); Serial.println(""); Serial.println("WiFi connected"); Serial.println("IP address: "); Serial.println(WiFi.localIP());&#125;void callback(char* topic, byte* payload, unsigned int length) &#123; Serial.print("Message arrived ["); Serial.print(topic); Serial.print("] "); char _msg[length + 1]; for (int i = 0; i &lt; length; i++) &#123; Serial.print((char)payload[i]); _msg[i] = (char) payload[i]; &#125; Serial.println(); Serial.print("msg = "); _msg[length] = 0; Serial.println(_msg); if (std::string(_msg) == "ON" || std::string(_msg) == "On" || std::string(_msg) == "on" ) &#123; digitalWrite(BUILTIN_LED, HIGH); &#125; else if(std::string(_msg) == "OFF" || std::string(_msg) == "Off" || std::string(_msg) == "off" )&#123; digitalWrite(BUILTIN_LED, LOW); &#125;&#125;void reconnect() &#123; // Loop until we're reconnected while (!client.connected()) &#123; Serial.print("Attempting MQTT connection..."); // Create a random client ID String clientId = "ESP32Client-"; clientId += String(random(0xffff), HEX); // Attempt to connect if (client.connect(clientId.c_str(), mqtt_user, mqtt_passwd)) &#123; Serial.println("connected"); // Once connected, publish an announcement... client.publish("outTopic", "hello world"); // ... and resubscribe client.subscribe("inTopic"); &#125; else &#123; Serial.print("failed, rc="); Serial.print(client.state()); Serial.println(" try again in 5 seconds"); // Wait 5 seconds before retrying delay(5000); &#125; &#125;&#125;void setup() &#123; pinMode(BUILTIN_LED, OUTPUT); // Initialize the BUILTIN_LED pin as an output Serial.begin(115200); setup_wifi(); client.setServer(mqtt_server, mqtt_port); client.setCallback(callback);&#125;void loop() &#123; if (!client.connected()) &#123; reconnect(); &#125; client.loop(); long now = millis(); if (now - lastMsg &gt; 2000) &#123; lastMsg = now; ++value; snprintf (msg, 50, "hello world #%ld", value); Serial.print("Publish message: "); Serial.println(msg); client.publish("outTopic", msg); &#125;&#125; TestIf you can’t open Youtube, Pls click this link.]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Remote Control LED via BLE of ESP32]]></title>
    <url>%2F2019%2F05%2F07%2FHow-to-Remote-Control-LED-via-BLE-of-ESP32%2F</url>
    <content type="text"><![CDATA[Requirements Turn on/off LED via Bluetooth Software12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;BLEDevice.h&gt;#include &lt;BLEServer.h&gt;#include &lt;BLEUtils.h&gt;#include &lt;BLE2902.h&gt; BLECharacteristic *pCharacteristic;bool deviceConnected = false;float txValue = 0;const int LED = 2; // Could be different depending on the dev board. I used the DOIT ESP32 dev board. #define SERVICE_UUID "6E400001-B5A3-F393-E0A9-E50E24DCCA9E" // UART service UUID#define CHARACTERISTIC_UUID_RX "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"#define CHARACTERISTIC_UUID_TX "6E400003-B5A3-F393-E0A9-E50E24DCCA9E" class MyServerCallbacks: public BLEServerCallbacks &#123; void onConnect(BLEServer* pServer) &#123; deviceConnected = true; &#125;; void onDisconnect(BLEServer* pServer) &#123; deviceConnected = false; &#125;&#125;; class MyCallbacks: public BLECharacteristicCallbacks &#123; void onWrite(BLECharacteristic *pCharacteristic) &#123; std::string rxValue = pCharacteristic-&gt;getValue(); if (rxValue.length() &gt; 0) &#123; Serial.println("*********"); Serial.print("Received Value: "); for (int i = 0; i &lt; rxValue.length(); i++) &#123; Serial.print(rxValue[i]); &#125; Serial.println(); // Do stuff based on the command received from the app if (rxValue == "ON" || rxValue == "On" || rxValue == "on") &#123; Serial.print("Turning ON!"); digitalWrite(LED, HIGH); &#125; else if (rxValue == "OFF" || rxValue == "Off" || rxValue == "off") &#123; Serial.print("Turning OFF!"); digitalWrite(LED, LOW); &#125; Serial.println(); Serial.println("*********"); &#125; &#125;&#125;;void setup() &#123; Serial.begin(115200); pinMode(LED, OUTPUT); // Create the BLE Device BLEDevice::init("ESP32_BLE_LED"); // Give it a name // Create the BLE Server BLEServer *pServer = BLEDevice::createServer(); pServer-&gt;setCallbacks(new MyServerCallbacks()); // Create the BLE Service BLEService *pService = pServer-&gt;createService(SERVICE_UUID); // Create a BLE Characteristic pCharacteristic = pService-&gt;createCharacteristic( CHARACTERISTIC_UUID_TX, BLECharacteristic::PROPERTY_NOTIFY ); pCharacteristic-&gt;addDescriptor(new BLE2902()); BLECharacteristic *pCharacteristic = pService-&gt;createCharacteristic( CHARACTERISTIC_UUID_RX, BLECharacteristic::PROPERTY_WRITE ); pCharacteristic-&gt;setCallbacks(new MyCallbacks()); // Start the service pService-&gt;start(); // Start advertising pServer-&gt;getAdvertising()-&gt;start(); Serial.println("Waiting a client connection to notify...");&#125; void loop() &#123; if (deviceConnected) &#123; pCharacteristic-&gt;setValue("Hello, this is a led test."); pCharacteristic-&gt;notify(); // Send the value to the app! &#125; delay(1000);&#125; Test Download nRF Connect from Goggle Paly ,Apple Store or github. Open the App and scan Bluetooth devices. Connect to “ESP32_BLE_LED” and send “on” or “off” to ESP.If you can’t open the above video, please click this link.]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install and Test MQTT Client C Library in Raspberry Pi]]></title>
    <url>%2F2019%2F05%2F04%2FInstall-and-Test-MQTT-Client-C-Library-in-Raspberry-Pi%2F</url>
    <content type="text"><![CDATA[Install MQTT Client C Library12345678apt updateapt install cmake libssl-devgit clone https://github.com/eclipse/paho.mqtt.c.gitcd paho.mqtt.cgit checkout v1.2.1cmake -Bbuild -H. -DPAHO_WITH_SSL=ONsudo cmake --build build/ --target installsudo ldconfig Test DemoEdit src/sample/CMakeLists.txt:12345678910111213141516171819202122232425262728293031323334353637383940diff --git a/src/samples/CMakeLists.txt b/src/samples/CMakeLists.txtindex 79ea886..230599a 100644--- a/src/samples/CMakeLists.txt+++ b/src/samples/CMakeLists.txt@@ -18,6 +18,7 @@ # Note: on OS X you should install XCode and the associated command-line tools ## compilation/linkage settings+cmake_minimum_required(VERSION 3.10) INCLUDE_DIRECTORIES( . $&#123;CMAKE_SOURCE_DIR&#125;/src@@ -51,15 +52,15 @@ TARGET_LINK_LIBRARIES(MQTTClient_subscribe paho-mqtt3c) TARGET_LINK_LIBRARIES(MQTTClient_publish paho-mqtt3c) TARGET_LINK_LIBRARIES(MQTTClient_publish_async paho-mqtt3c)-INSTALL(TARGETS paho_c_sub- paho_c_pub- paho_cs_sub- paho_cs_pub- MQTTAsync_subscribe- MQTTAsync_publish- MQTTClient_subscribe- MQTTClient_publish- MQTTClient_publish_async-- RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;- LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;)+#INSTALL(TARGETS paho_c_sub+# paho_c_pub+# paho_cs_sub+# paho_cs_pub+# MQTTAsync_subscribe+# MQTTAsync_publish+# MQTTClient_subscribe+# MQTTClient_publish+# MQTTClient_publish_async+#+# RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;+# LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;) Edit MQTTClient_publish_async.c and MQTTClient_subscribe.c:123456789101112131415161718192021diff --git a/src/samples/MQTTClient_publish_async.c b/src/samples/MQTTClient_publish_async.cindex 7784349..57ef1ab 100644--- a/src/samples/MQTTClient_publish_async.c+++ b/src/samples/MQTTClient_publish_async.c@@ -19,7 +19,7 @@ #include &lt;string.h&gt; #include "MQTTClient.h"-#define ADDRESS "tcp://localhost:1883"+#define ADDRESS "tcp://example.com:11111" #define CLIENTID "ExampleClientPub" #define TOPIC "MQTT Examples" #define PAYLOAD "Hello World!"@@ -72,6 +72,8 @@ int main(int argc, char* argv[]) MQTTCLIENT_PERSISTENCE_NONE, NULL); conn_opts.keepAliveInterval = 20; conn_opts.cleansession = 1;+ conn_opts.username = "username";+ conn_opts.password = "passwd"; MQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered); 123456789101112131415161718192021diff --git a/src/samples/MQTTClient_subscribe.c b/src/samples/MQTTClient_subscribe.cindex c675ecc..e99fd84 100644--- a/src/samples/MQTTClient_subscribe.c+++ b/src/samples/MQTTClient_subscribe.c@@ -19,7 +19,7 @@ #include &lt;string.h&gt; #include "MQTTClient.h"-#define ADDRESS "tcp://localhost:1883"+#define ADDRESS "tcp://example.com:11111" #define CLIENTID "ExampleClientSub" #define TOPIC "MQTT Examples" #define PAYLOAD "Hello World!"@@ -71,6 +71,8 @@ int main(int argc, char* argv[]) MQTTCLIENT_PERSISTENCE_NONE, NULL); conn_opts.keepAliveInterval = 20; conn_opts.cleansession = 1;+ conn_opts.username = "username";+ conn_opts.password = "passwd"; MQTTClient_setCallbacks(client, NULL, connlost, msgarrvd, delivered); Type the below command:12345mkdir buildcd buildcmake ..make.MQTTClient_subscribe Open another terminal:./MQTTClient_publish_async Result:]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>MQTT</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to setup your private MQTT server]]></title>
    <url>%2F2019%2F05%2F02%2FHow-to-setup-your-private-MQTT-server%2F</url>
    <content type="text"><![CDATA[Install MQTT Software Package12apt updateapt install mosquitto Configure and Start MQTT ServiceEdit /etc/mosquitto/mosquitto.conf, and append the following contents:123456#change default portport 11111 #deny anonymousallow_anonymous false #select password filepassword_file /etc/mosquitto/passwd Then, generate password file for MQTT service.1mosquitto_passwd -c /etc/mosquitto/passwd username If you want to add one more user, you can:1mosquitto_passwd /etc/mosquitto/passwd another_username Finally, start MQTT service:1systemctl restart mosquitto Test MQTT ServiceMAC OS ClientDownload MQTTBox software from Apple Store. Chrome PluginSearch MQTTLens in Chrome APP Store and install it.]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Configure your Wifi Information via WebServer]]></title>
    <url>%2F2019%2F05%2F02%2FConfigure-your-Wifi-Information-via-Browser%2F</url>
    <content type="text"><![CDATA[Requirments Start a WebServer with ESP32 Control LED by browser Input your Wifi information by browser and enable connect SPIFFS filesYou can download some web files via https://github.com/kaylorchen/ESP32/tree/master/WebConfig/data, and save them to your datadirectory.Upload these files to your image: Terminal -&gt; Run task -&gt; PlatformIO: Upload file system image Software123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;WiFi.h&gt;#include &lt;WiFiClient.h&gt;#include &lt;WebServer.h&gt;#include &lt;ESPmDNS.h&gt;#include "SPIFFS.h"#include "FS.h"bool loadFromSpiffs(String path);char ssid[50] = "";char password[50] = "";WebServer server(80);const int led = 2;void listDir(fs::FS &amp;fs, const char * dirname, uint8_t levels)&#123; Serial.printf("Listing directory: %s\r\n", dirname); File root = fs.open(dirname); if(!root)&#123; Serial.println("- failed to open directory"); return; &#125; if(!root.isDirectory())&#123; Serial.println(" - not a directory"); return; &#125; File file = root.openNextFile(); while(file)&#123; if(file.isDirectory())&#123; Serial.print(" DIR : "); Serial.println(file.name()); if(levels)&#123; listDir(fs, file.name(), levels -1); &#125; &#125; else &#123; Serial.print(" FILE: "); Serial.print(file.name()); Serial.print("\tSIZE: "); Serial.println(file.size()); &#125; file = root.openNextFile(); &#125;&#125;void handleRoot() &#123; server.sendHeader("Location", "/index.html",true); //Redirect to our html web page server.send(302, "text/plane","");&#125;void handleLED()&#123; if(server.hasArg("value"))&#123; String action = server.arg("value"); if( action == "ON")&#123; digitalWrite(led, 1); server.send(200, "text/html", "ON"); return; &#125;else if( action == "OFF")&#123; digitalWrite(led, 0); server.send(200, "text/html", "OFF"); return; &#125; &#125;&#125;void handleWifi()&#123; if(server.hasArg("config"))&#123; String config = server.arg("config"); String wifiname; String wifipwd; if(config == "on")&#123; if(server.hasArg("name"))&#123; wifiname = server.arg("name"); &#125; if(server.hasArg("pwd"))&#123; wifipwd = server.arg("pwd"); &#125; Serial.println("ssid: "+ wifiname +"\r\npassword: " + wifipwd); wifiname.toCharArray(ssid, 50); wifipwd.toCharArray(password, 50); WiFi.mode(WIFI_STA); if(WiFi.status() == WL_CONNECTED)&#123; Serial.println("disconnect the original Wifi"); WiFi.disconnect(); &#125; Serial.println("handle Wifi end"); &#125; &#125; &#125;void handleWebRequests()&#123; if(loadFromSpiffs(server.uri())) return; String message = "File Not Detected\n\n"; message += "URI: "; message += server.uri(); message += "\nMethod: "; message += (server.method() == HTTP_GET)?"GET":"POST"; message += "\nArguments: "; message += server.args(); message += "\n"; for (uint8_t i=0; i&lt;server.args(); i++)&#123; message += " NAME:"+server.argName(i) + "\n VALUE:" + server.arg(i) + "\n"; &#125; server.send(404, "text/plain", message); Serial.println(message);&#125;void softAPConfig()&#123; Serial.println("Configuring access point..."); // You can remove the password parameter if you want the AP to be open. uint32_t chipID = ESP.getEfuseMac(); String apName = "ESP32_" + String(chipID, HEX); Serial.println("AP name: " + apName ); WiFi.mode(WIFI_AP); WiFi.softAP(apName.c_str()); IPAddress myIP = WiFi.softAPIP(); Serial.print("AP IP address: "); Serial.println(myIP); &#125;void wifiConfig()&#123; Serial.print("Connecting to "); Serial.println(ssid); Serial.print("Password: "); Serial.println(password); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print("."); &#125; Serial.println(""); Serial.println("WiFi connected"); Serial.println("IP address: "); Serial.println(WiFi.localIP());&#125;void setup() &#123; // put your setup code here, to run once: pinMode(led, OUTPUT); digitalWrite(led, 0); Serial.begin(115200); delay(3000); if(!SPIFFS.begin(true))&#123; Serial.println("An Error has occurred while mounting SPIFFS"); return; &#125; listDir(SPIFFS, "/", 0); softAPConfig(); server.on("/", handleRoot); server.on("/led", HTTP_GET, handleLED); server.on("/wifi", HTTP_GET, handleWifi); server.onNotFound(handleWebRequests); server.begin(); Serial.println("HTTP server started");&#125;void loop() &#123; // put your main code here, to run repeatedly: server.handleClient(); if(WiFi.status() != WL_CONNECTED &amp;&amp; WiFi.getMode() == WIFI_STA)&#123; wifiConfig(); &#125;&#125;bool loadFromSpiffs(String path)&#123; String dataType = "text/plain"; if(path.endsWith("/")) path += "index.htm"; if(path.endsWith(".src")) path = path.substring(0, path.lastIndexOf(".")); else if(path.endsWith(".html")) dataType = "text/html"; else if(path.endsWith(".htm")) dataType = "text/html"; else if(path.endsWith(".css")) dataType = "text/css"; else if(path.endsWith(".js")) dataType = "application/javascript"; else if(path.endsWith(".png")) dataType = "image/png"; else if(path.endsWith(".gif")) dataType = "image/gif"; else if(path.endsWith(".jpg")) dataType = "image/jpeg"; else if(path.endsWith(".ico")) dataType = "image/x-icon"; else if(path.endsWith(".xml")) dataType = "text/xml"; else if(path.endsWith(".pdf")) dataType = "application/pdf"; else if(path.endsWith(".zip")) dataType = "application/zip"; File dataFile = SPIFFS.open(path.c_str(), "r"); if (server.hasArg("download")) dataType = "application/octet-stream"; if (server.streamFile(dataFile, dataType) != dataFile.size()) &#123; &#125; Serial.println(path); dataFile.close(); return true;&#125; Result: If you can’t open Youtube, and please open this link.]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Test SPIFFS]]></title>
    <url>%2F2019%2F05%2F02%2FHow-to-Test-SPIFFS%2F</url>
    <content type="text"><![CDATA[Requirements Upload files to SPIFFS independently. Read files and display its contents in the monitor. Upload FilesCreate a new data directory in the project root directory, and generate a txt file named “kaylor.txt“. This file’s contents are written as follows;I am interested in you. Terminal -&gt; Run task -&gt; PlatformIO: Upload file system image, you will see logs as follows:12345678910111213141516171819202122232425262728293031323334353637Processing esp32dev (platform: espressif32; board: esp32dev; framework: arduino)-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Verbose mode can be enabled via `-v, --verbose` optionCONFIGURATION: https://docs.platformio.org/page/boards/espressif32/esp32dev.htmlPLATFORM: Espressif 32 &gt; Espressif ESP32 Dev ModuleHARDWARE: ESP32 240MHz 320KB RAM (4MB Flash)DEBUG: CURRENT(esp-prog) EXTERNAL(esp-prog, iot-bus-jtag, jlink, minimodule, olimex-arm-usb-ocd, olimex-arm-usb-ocd-h, olimex-arm-usb-tiny-h, olimex-jtag-tiny, tumpa)Converting FS.inoLibrary Dependency Finder -&gt; http://bit.ly/configure-pio-ldfLDF MODES: FINDER(chain) COMPATIBILITY(soft)Collected 26 compatible librariesScanning dependencies...Dependency Graph|-- &lt;SPIFFS&gt; 1.0| |-- &lt;FS&gt; 1.0|-- &lt;FS&gt; 1.0Building SPIFFS image from &apos;data&apos; directory to .pioenvs\esp32dev\spiffs.bin/kaylor.txtLooking for upload port...Auto-detected: COM13Uploading .pioenvs\esp32dev\spiffs.binesptool.py v2.6Serial port COM13Connecting........__Chip is ESP32D0WDQ6 (revision 1)Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme NoneMAC: cc:50:e3:a9:51:a4Uploading stub...Running stub...Stub running...Changing baud rate to 921600Changed.Configuring flash size...Auto-detected Flash size: 4MBCompressed 1503232 bytes to 2863...Wrote 1503232 bytes (2863 compressed) at 0x00291000 in 0.1 seconds (effective 210979.3 kbit/s)...Hash of data verified. Software123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include "SPIFFS.h"#include "FS.h"void listDir(fs::FS &amp;fs, const char * dirname, uint8_t levels)&#123; Serial.printf("Listing directory: %s\r\n", dirname); File root = fs.open(dirname); if(!root)&#123; Serial.println("- failed to open directory"); return; &#125; if(!root.isDirectory())&#123; Serial.println(" - not a directory"); return; &#125; File file = root.openNextFile(); while(file)&#123; if(file.isDirectory())&#123; Serial.print(" DIR : "); Serial.println(file.name()); if(levels)&#123; listDir(fs, file.name(), levels -1); &#125; &#125; else &#123; Serial.print(" FILE: "); Serial.print(file.name()); Serial.print("\tSIZE: "); Serial.println(file.size()); &#125; file = root.openNextFile(); &#125;&#125;void setup() &#123; // put your setup code here, to run once: Serial.begin(115200); if(!SPIFFS.begin(true))&#123; Serial.println("An Error has occurred while mounting SPIFFS"); return; &#125; listDir(SPIFFS, "/", 0); File file = SPIFFS.open("/kaylor.txt"); if(!file)&#123; Serial.println("Failed to open file for reading"); return; &#125; Serial.println("File Content:"); while(file.available())&#123; Serial.write(file.read()); &#125; file.close();&#125;void loop() &#123; // put your main code here, to run repeatedly:&#125; Result:]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Connect to your Wifi with ESP32]]></title>
    <url>%2F2019%2F05%2F02%2FConnect-to-your-Wifi-with-ESP32%2F</url>
    <content type="text"><![CDATA[Requirements Connect to a Wifi as a station Software123456789101112131415161718192021222324252627282930313233#include &lt;WiFi.h&gt;const char* ssid = "Xiaomi_kaylordut";const char* password = "kaylordut.com";void setup()&#123; Serial.begin(115200); delay(10); // We start by connecting to a WiFi network Serial.println(); Serial.println(); Serial.print("Connecting to "); Serial.println(ssid); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print("."); &#125; Serial.println(""); Serial.println("WiFi connected"); Serial.println("IP address: "); Serial.println(WiFi.localIP());&#125;void loop()&#123;&#125; Result:]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Setup a softAP with ESP32]]></title>
    <url>%2F2019%2F05%2F01%2FSet-a-softAP-with-ESP32%2F</url>
    <content type="text"><![CDATA[Requirements Setup a softAP with ESP32 Control LED with the browser Software1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;WiFi.h&gt;#include &lt;WiFiClient.h&gt;#include &lt;WiFiAP.h&gt;#define LED_BUILTIN 2 // Set the GPIO pin where you connected your test LED or comment this line out if your dev board has a built-in LED// Set these to your desired credentials.const char *ssid = "Kaylor test";const char *password = "00000000";WiFiServer server(80);void setup() &#123; pinMode(LED_BUILTIN, OUTPUT); Serial.begin(115200); Serial.println(); Serial.println("Configuring access point..."); // You can remove the password parameter if you want the AP to be open. WiFi.softAP(ssid, password); IPAddress myIP = WiFi.softAPIP(); Serial.print("AP IP address: "); Serial.println(myIP); server.begin(); Serial.println("Server started");&#125;void loop() &#123; WiFiClient client = server.available(); // listen for incoming clients if (client) &#123; // if you get a client, Serial.println("New Client."); // print a message out the serial port String currentLine = ""; // make a String to hold incoming data from the client while (client.connected()) &#123; // loop while the client's connected if (client.available()) &#123; // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out the serial monitor if (c == '\n') &#123; // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) &#123; // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println("HTTP/1.1 200 OK"); client.println("Content-type:text/html"); client.println(); // the content of the HTTP response follows the header: client.print("Click &lt;a href=\"/H\"&gt;here&lt;/a&gt; to turn ON the LED.&lt;br&gt;"); client.print("Click &lt;a href=\"/L\"&gt;here&lt;/a&gt; to turn OFF the LED.&lt;br&gt;"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; &#125; else &#123; // if you got a newline, then clear currentLine: currentLine = ""; &#125; &#125; else if (c != '\r') &#123; // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine &#125; // Check to see if the client request was "GET /H" or "GET /L": if (currentLine.endsWith("GET /H")) &#123; digitalWrite(LED_BUILTIN, HIGH); // GET /H turns the LED on &#125; if (currentLine.endsWith("GET /L")) &#123; digitalWrite(LED_BUILTIN, LOW); // GET /L turns the LED off &#125; &#125; &#125; // close the connection: client.stop(); Serial.println("Client Disconnected."); &#125;&#125; Open your phone WLAN settings, and connect the SSID: Kaylor test, Password is “00000000”.You will see some log in the monitor window as follows:Open the browser and type: 192.168.4.1]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to control GPIO of ESP32]]></title>
    <url>%2F2019%2F05%2F01%2FHow-to-control-GPIO-of-ESP32%2F</url>
    <content type="text"><![CDATA[Hardware Software123456789101112131415161718192021222324#include "Arduino.h"// constants won't change. Used here to set a pin number:const int ledPin = 2;// the number of the LED pinconst int buttonPin = 0;uint8_t value = 0;void setup() &#123; // set the digital pin as output/input: pinMode(ledPin, OUTPUT); pinMode(buttonPin, INPUT); Serial.begin(115200);&#125;void loop() &#123; value = digitalRead(buttonPin); Serial.printf("Button = %d\n\r",value); if (value == 0) &#123; // set the LED with 1 when button is pressed: digitalWrite(ledPin, 1); &#125; else&#123; digitalWrite(ledPin, 0); &#125; &#125; When the button is pressed, LED will be ON.]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The First ESP32 Project]]></title>
    <url>%2F2019%2F04%2F30%2FFirst-ESP32-Project%2F</url>
    <content type="text"><![CDATA[Initialize the ProjectOpen Visual Studio Code, New Project: Append a new line in platformio.ini, the final file follow as:12345[env:esp32dev]platform = espressif32board = esp32devframework = arduinomonitor_speed = 115200 Program Application CodeEdit src/main.cpp.1234567891011#include "Arduino.h"uint64_t chipid; void setup()&#123; Serial.begin(115200);&#125;void loop()&#123; chipid=ESP.getEfuseMac();//The chip ID is essentially its MAC address(length: 6 bytes). Serial.printf("ESP32 Chip ID = %04X",(uint16_t)(chipid&gt;&gt;32));//print High 2 bytes Serial.printf("%08X\n",(uint32_t)chipid);//print Low 4bytes. delay(1500);&#125;]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Setup an ESP32 Arduino development environment]]></title>
    <url>%2F2019%2F04%2F30%2FSetup-an-ESP32-Arduino-development-environment%2F</url>
    <content type="text"><![CDATA[Download and Install Visual Studio CodeDownload Visual Studio Code from https://code.visualstudio.com/, and install it. Install PlatformIO Plugin Install ESP32 LibraryOpen a new terminal, and type:1pio platform install &quot;espressif32&quot;]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>Arduino</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remote Desktop I: Install NoMachine in TX2]]></title>
    <url>%2F2019%2F04%2F30%2FRemote-Desktop-I-Install-NoMachine-in-TX2%2F</url>
    <content type="text"><![CDATA[Most remote desktops do not support the ARM platform, but NoMachine is an exception. NoMachine has comparable performance to teamviewer. Install NoMachine in TX2Download NoMachineDownload NoMachine by BrowserDownload NoMachine from https://www.nomachine.com/download/linux&amp;id=30&amp;s=ARM.Select NoMachine for ARM ARMv8 DEB Download NoMachine by Terminal12cd /tmpwget https://download.nomachine.com/download/6.6/Arm/nomachine_6.6.8_7_arm64.deb If the NoMachine version is updated, the above link will be invalid, Install NoMachine12cd /tmpsudo dpkg -i nomachine*arm64.deb Configure TX2 ResolutionInstall driver:1sudo apt install xserver-xorg-video-dummy sudo vi /etc/X11/xorg.conf as follow:123456789101112131415161718192021222324252627282930# Copyright (c) 2015, NVIDIA CORPORATION. All Rights Reserved.## This is the minimal configuration necessary to use the Tegra driver.# Please refer to the xorg.conf man page for more configuration# options provided by the X server, including display-related options# provided by RandR 1.2 and higher.# Disable extensions not useful on Tegra.Section &quot;Module&quot; Disable &quot;dri&quot; SubSection &quot;extmod&quot; Option &quot;omit xfree86-dga&quot; EndSubSectionEndSectionSection &quot;Device&quot; Identifier &quot;Tegra0&quot; Driver &quot;nvidia&quot; Option &quot;AllowEmptyInitialConfiguration&quot; &quot;true&quot;EndSectionSection &quot;Screen&quot; Identifier &quot;Default Screen&quot; Monitor &quot;Configured Monitor&quot; Device &quot;Configured Video Device&quot; SubSection &quot;Display&quot; Depth 24 Modes &quot;1920x1080&quot; EndSubSectionEndSection PS: You can modify Modes “1920x1080”.]]></content>
      <categories>
        <category>Remote Desktop</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Remote Desktop</tag>
        <tag>TX2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Write/Read GPIO in your Raspberry Pi with WiringPi Library]]></title>
    <url>%2F2019%2F04%2F30%2FWrite-Read-GPIO-in-your-Raspberry-Pi-with-WiringPi-Library%2F</url>
    <content type="text"><![CDATA[Edit GPIO Permission Create a rule file: /lib/udev/rules.d/60-gpio.rules 12KERNEL==&quot;spidev*&quot;, GROUP=&quot;spi&quot;, MODE=&quot;0660&quot;SUBSYSTEM==&quot;gpio*&quot;, PROGRAM=&quot;/bin/sh -c &apos;chown -R root:gpio /sys/class/gpio &amp;&amp; chmod -R 770 /sys/class/gpio; chown -R root:gpio /sys/devices/virtual/gpio &amp;&amp; chmod -R 770 /sys/devices/virtual/gpio; chown -R root:gpio /sys/devices/platform/soc/*.gpio/gpio &amp;&amp; chmod -R 770 /sys/devices/platform/soc/*.gpio/gpio&apos;&quot; Add root user to GPIO group 123groupadd gpiousermod -a -G gpio rootreboot Edit C++ code:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include "wiringPi.h"void loop(uint16_t cnt, int ctlPin, int sigPin)&#123; pinMode(ctlPin, OUTPUT); pullUpDnControl(ctlPin, PUD_DOWN); pinMode(sigPin, INPUT); while (cnt --) &#123; digitalWrite(ctlPin, 1);// delay(5000); uint8_t sig = digitalRead(sigPin); while(sig) &#123; printf("sig state: %d\n",sig); delay(10); sig = digitalRead(sigPin); &#125; printf("___sig state: %d\n",sig); delay(10); while(!sig) &#123; printf("sig state: %d\n",sig); delay(10); sig = digitalRead(sigPin); &#125; printf("###sig state: %d\n",sig); digitalWrite(ctlPin, 0); &#125;&#125;int main()&#123; if (wiringPiSetup() &lt; 0) return 1; loop(1, 24, 25); return 0;&#125; Edit CMakelists.txt123456789cmake_minimum_required(VERSION 3.10)project(test)set(CMAKE_CXX_STANDARD 11)find_library(wiringPi_LIB wiringPi)find_package(Threads)add_executable(test main.cpp)target_link_libraries(test $&#123;wiringPi_LIB&#125; $&#123;CMAKE_THREAD_LIBS_INIT&#125; rt crypt) Test your program1234mkdir buildcd buildmakesudo ./test]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install WiringPi library in Raspberry Pi]]></title>
    <url>%2F2019%2F04%2F30%2FInstall-WiringPi-library-in-Raspberry-Pi%2F</url>
    <content type="text"><![CDATA[Git WiringPi source123git clone git://git.drogon.net/wiringPicd wiringPi./build]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install Ubuntu 18.04 in Raspberry Pi Mode 3B+]]></title>
    <url>%2F2019%2F04%2F30%2FInstall-Ubuntu-18-04-in-Raspberry-Pi-Mode-3B%2F</url>
    <content type="text"><![CDATA[Download the ImageDownload the image from https://wiki.ubuntu.com/ARM/RaspberryPi. ARMHF: Hard float for ARM (32bit) ARM64: 64bitARMHF compatibility is better than ARM64 compatibility. Install Ubuntu 18.04Get balenaEtcher from https://www.balena.io/etcher/]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Deploy N2N VPN]]></title>
    <url>%2F2019%2F04%2F30%2FHow-to-Deploy-N2N-VPN%2F</url>
    <content type="text"><![CDATA[n2n is an open source Layer 2 over Layer 3 VPN application which utilises a peer-to-peer architecture for network membership and routing. Some details can be found in https://www.ntop.org/products/n2n/. N2N communication method Edge node Super node Edge node Edge node Other edge nodes Edge node Edge node Edge node Method 3 is a direct connection, and data will not pass the super node. This is the most ideal way. Deploy Super Node in your VPS (Ubuntu 16.04)Compile your N2N:1234git clone https://github.com/meyerd/n2n.gitcd n2n/n2n_v2cmake ./make &amp;&amp; make install Start your super node, listen port is set as 6666:1supernode -l 6666 Configure Your Windows ClientDownload a client from https://file.bugxia.com/s/b6MAp6LS78b6XBp. Install TAP Adapter Configure Client服务器地址: Server IP端口： Port本机IP：Local IP组名称：Group组密码：Password Configure Your MAC ClientCompile your N2N:12git clone https://github.com/meyerd/n2n.gitcd n2n/n2n_v2 Modify n2n/n2n_v2/CMakeLists.txt.CMAKE_C_FLAGS and CMAKE_CXX_FLAGS append -I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib1234mkdir buildcd buildmakesudo make install modify your ~/.bash_profile and append a new line: export PATH=$PATH:/usr/local/sbin/ Using n2n on MacOSIn order to use n2n on MacOS you need to first install support for the tap interface.if you are a brew (https://brew.sh) user you can do it in a couple of steps brew tap homebrew/cask brew cask install tuntap Note that in the latest OS versions (for instance MacOS High Sierra), you may need toneed to enable their kernel extension in System Preferences → Security &amp; Privacy → General Start Your Client1sudo edge -d n2n0 -c kaylor k 123456 -l your_server_ip:6666 -a 192.168.100.200 -b -r]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>N2N</tag>
        <tag>MAC OS</tag>
        <tag>Winodows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业前随想]]></title>
    <url>%2F2016%2F06%2F15%2F%E6%AF%95%E4%B8%9A%E5%89%8D%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[人家说七年是人体把细胞更新一轮的周期，也就是说我再也不会是七年前的那个意气风发的少年了吧。学妹说当你回首过去的时候，感叹那时的幼稚说明你成长了，感觉那时很美好说明你老了。问题是，我怎么感觉又幼稚又美好呢。 今天刚好看到一段话——“我只知道，重回当年选择的那一刻，基于我当时的视野范围和认知水平，我做了我认为最好的选择。是好还是坏，这就是我无法改变不能回头的了。” 确实，上一次毕业做了当时自己认为最好的选择，即使在现在看来也从无后悔，只是徒添了一些遗憾吧，总感觉有些未完成的梦。 这一路上，自己也许做了自己所有能够去做的、去争取的事情，涉足了许多本不属于自己的领域。终于被生活被境遇慢慢带离了自己的轨道，两年前的那个时候是真的hold不住生活，对未来的恐惧，对自己的不自信，我依稀记得仿佛被抽空了灵魂的感觉。总是因为太过于孤注一掷，把生活过得太压抑的结果。 时间这种东西，其实并不能改变什么。我们只是在时间的长河里奔赴一个个的下一站，我们遇见了不同的人，看尽别人不同的人生。然后我终于明白，那年那些选择那些放弃和坚持，都是基于当时我们的视野范围和认知水平，做出了最合乎自己心意的事情罢了。生活慢慢地回到自己的轨道上，以前对未来不确定的恐惧渐渐地变得对未来那些无限的可能期待。不再去过多的纠结于那些被普遍认为的重要的人生的十字路口，毕竟那些决定都已经在自己心里做好，那些决定都是基于自己的学识而做出的。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deploy a Transparent Proxy with Squid]]></title>
    <url>%2F2016%2F01%2F06%2FDeploy-a-Transparent-Proxy-with-Squid%2F</url>
    <content type="text"><![CDATA[Sometimes, we want to have a local transparent proxy, and it will provide http, https and e-mail’s proxy.Why do we need a local proxy? As we know, most of routers don’t support Ipv6. If there is a router with ipv6 in a local area network, and it also is proxy server, so other device will browse a ipv6 homepage via proxy.OK, let’s begin:12apt-get updateapt-get install squid Edit squid’s configuration file, it’s path is /etc/squid3/squid.conf. there is a reference file:12345678910111213141516171819202122232425262728acl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECThttp_access deny !Safe_portshttp_access deny CONNECT !SSL_portshttp_access allow localhost managerhttp_access deny managerhttp_access allow localhostacl openvpn6 src 10.8.6.0/24http_access allow openvpn6http_access deny allhttp_port 3128coredump_dir /var/spool/squid3refresh_pattern ^ftp: 1440 20% 10080refresh_pattern ^gopher: 1440 0% 1440refresh_pattern -i (/cgi-bin/|\?) 0 0% 0refresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880refresh_pattern . 0 20% 4320forwarded_for transparent After all the above steps, enter a command and restart service.1/etc/init.d/squid3 restart Finally, configure your browser with “server’s ip” and “port”(3128).]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wifi Smart Car Ⅳ : Hardware and MCU’s Programming]]></title>
    <url>%2F2015%2F11%2F28%2FWifi-Smart-Car-%E2%85%A3-Hardware-and-MCU%E2%80%99s-Programming%2F</url>
    <content type="text"><![CDATA[Hardware design and programming had been upload to my github. Pls click here.]]></content>
      <categories>
        <category>Wifi Smart Car</category>
      </categories>
      <tags>
        <tag>Wifi Smart Car</tag>
        <tag>OpenWRt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wifi Smart Car Ⅲ : Devolop a PC Client]]></title>
    <url>%2F2015%2F11%2F23%2FWifi-Smart-Car-%E2%85%A2-Devolop-a-PC-Client%2F</url>
    <content type="text"><![CDATA[My PC client was developed with C# by myself.you can get the client’s source from my github.]]></content>
      <categories>
        <category>Wifi Smart Car</category>
      </categories>
      <tags>
        <tag>Wifi Smart Car</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wifi Smart Car Ⅱ: Communication by Using Ser2net]]></title>
    <url>%2F2015%2F11%2F17%2FWifi-Smart-Car-%E2%85%A1-Communication-by-Using-Ser2net%2F</url>
    <content type="text"><![CDATA[Ser2net is a software that can convert data between net and serial port.12opkg update opkg install ser2net Use command ls /dev/tty*, and find the router’s serial port is called as ttyATH0.Edit the /etc/ser2net.conf, find a line by searching for “2001” within this file and change it as following: 12001:raw:600:/dev/ttyATH0:115200 NONE 1STOPBIT 8DATABITS XONXOFF LOCAL -RTSCTS Start ser2net server with command: ser2netConnect router’s uart to PC, and open serial port debugging assistant.Open your command prompt or terminal, type telnet router_ip 2001. My router ip is 192.168.1.110, so I enter telnet 192.168.1.110 2001. Now, test this server. I can type some characters in terminal, they are shown in serial port debugging assistant and vice versa.]]></content>
      <categories>
        <category>Wifi Smart Car</category>
      </categories>
      <tags>
        <tag>OpenWRT</tag>
        <tag>Wifi Smart Car</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wifi Smart Car Ⅰ: Connect Your Camera]]></title>
    <url>%2F2015%2F11%2F15%2FWifi-Smart-Car-%E2%85%A0-Connect-Your-Camera%2F</url>
    <content type="text"><![CDATA[Hardware GL.inet AR150 or GL.inet 6416/6408 Logitech C270 camera I update the router with TP-WR720N‘s firmware. Install usb driver and mjpg server12opkg updateopkg install kmod-usb2 kmod-usb-ohci kmod-video-gspca-core kmod-video-core kmod-video-uvc kmod-i2c-core kmod-input-core mjpg-streamer Configurate mjpg server1vi /etc/config/mjpg-streamer the details are as follow:12345678910config mjpg-streamer &apos;core&apos; option enabled &apos;1&apos; option input &apos;uvc&apos; option output &apos;http&apos; option device &apos;/dev/video0&apos; option resolution &apos;640x480&apos; option fps &apos;60&apos; option www &apos;/www/webcam&apos; option port &apos;8080&apos; option yuv &apos;0&apos; TestRestart your router, and type router_ip:8080 in your address bar of browser. you will see: PS: some router need to enable USB device. For instance, AR150′s USB device is enabled by GPIO6.1234echo 6 &gt; /sys/class/gpio/export # Load GPIO6echo out &gt; /sys/class/gpio/gpio6/direction # Set direction as outecho 1 &gt; /sys/class/gpio/gpio6/value # Set output level as high, enable USB deviceecho 6 &gt; /sys/class/gpio/unexport # Unload GPIO, but output level keep the current voltage]]></content>
      <categories>
        <category>Wifi Smart Car</category>
      </categories>
      <tags>
        <tag>OpenWRT</tag>
        <tag>Wifi Smart Car</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Deploy your Private NAS with your OpenWrt Router]]></title>
    <url>%2F2015%2F11%2F11%2FHow-to-Deploy-your-Private-NAS-with-your-OpenWrt-Router%2F</url>
    <content type="text"><![CDATA[Firstly, we should install USB storage prerequisites.12opkg updateopkg install kmod-usb-storage block-mount kmod-fs-ext4 kmod-usb-storage-extras kmod-scsi-core e2fsprogs fdisk If your device’s filesystem isn’t ext4 or ext3, I sugguest to format it.1fdisk /dev/sda Delete old partitions and creat new partitions with fdisk.Format your device and mount it:12mkfs.ext4 /dev/sdamount -t ext4 /dev/sda /mnt/ Install samba server:12opkg install samba36-servervi /etc/config/samba 12345678910config samba option &apos;name&apos; &apos;OpenWrt&apos; option &apos;workgroup&apos; &apos;WORKGROUP&apos; option &apos;description&apos; &apos;OpenWrt&apos; option &apos;homes&apos; &apos;1&apos;config sambashare option name &apos;share&apos; option path &apos;mnt&apos; option read_only &apos;no&apos; option guest_ok &apos;no&apos; Edit /etc/samba/smb.conf.template, and delete invalid users = root. Next:smbpasswd -a root Enter your samba server’s password.Now, all the configurations are completed. Start samba server:/etc/init.d/samba start Finally, Connect our server with PC. “win+R” and enter “\x.x.x.x”. If you want to use IPv6 address, you can append a line “2001:da8:a800::xxxx(server) samba_server” in your hosts. Use “\samba_server” instead of “\x.x.x.x”.If your device is a Android phone, you can install a APP named “Shared Viewer” from Google Play.]]></content>
      <categories>
        <category>OpenWRT</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DM8168 Uboot support EMAC1]]></title>
    <url>%2F2015%2F11%2F11%2FDM8168-Uboot-support-EMAC1%2F</url>
    <content type="text"><![CDATA[We only designed a Ethernet interface with Emac1, so I had to modified the Uboot sources from TI.MII interface is a manager to read the PHY address of network chip when this interface is initialized. The value of the PHY address will be save in a 32-bit register. For example, the address is 3, and the value will be 0×00000008. The value’s 3rd bit is set as ’1′, so I find the value is 0×08, not 0×03. I have come to the conclusion that a MII interface can manage 32 network chip at most. Edit arch/arm/include/asm/arch-ti81xx/emac_defs.h,123#define EMAC_MDIO_PHY_NUM 3#define EMAC_MDIO_PHY_MASK (1 &lt; &lt; EMAC_MDIO_PHY_NUM) So its mask is 0×08. Next, change EMAC based address:1234567891011121314151617181920212223242526272829303132333435363738//#define EMAC0#ifdef EMAC0#define EMAC_MDIO_PHY_NUM (1)#define EMAC_BASE_ADDR (0x4A100000)#define EMAC_WRAPPER_BASE_ADDR (0x4A100900)#define EMAC_WRAPPER_RAM_ADDR (0x4A102000)#else#define EMAC_MDIO_PHY_NUM (3)#define EMAC_WRAPPER_RAM_ADDR (0x4A122000)#define EMAC_WRAPPER_BASE_ADDR (0x4A120900)#define EMAC_BASE_ADDR (0x4A120000)#endif#define EMAC_MDIO_BASE_ADDR (0x4A100800)#define DAVINCI_EMAC_VERSION2#define DAVINCI_EMAC_GIG_ENABLE#define EMAC_MDIO_BUS_FREQ (250000000UL)#define EMAC_MDIO_CLOCK_FREQ (2000000UL)In default configuration, Emac0′s IO is configurated by default, but Emac1′s IO should been configurated extra. Edit drivers/net/davinci_emac.c :#ifndef EMAC0#define EMAC1_PINCTRL_BASE *( volatile unsigned int* )( 0x481408C8 )/*Initialize EMAC1 pins */pReg = &amp;amp;EMAC1_PINCTRL_BASE;for ( i = 0 ; i &lt; 24 ; i++ )&#123;debug_emac(&quot;Before : 0x%08x\t&quot;,readl(pReg));writel(readl(pReg)|0x01,pReg);debug_emac(&quot;After : 0x%08x\n&quot;,readl(pReg));pReg++;&#125;#endif The initialization of the network chip may not been completed when CPU reads network chip, because CPU speed is too fast. The network will be invalid in this case. we can find a method in davinci_emac_initialize().1234567for (i = 0; i &lt; 256; i++) &#123;alive = readl(&amp;amp;adap_mdio-&gt;ALIVE);// printf("times:%03d,alive:0x%08x\n",i,alive);if (alive)break;udelay(10);&#125; We can increase time delay to fix this issue.]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
        <tag>DM8168</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Realize QoS in your Openwrt Router]]></title>
    <url>%2F2015%2F11%2F07%2FHow-to-Realize-QoS-in-your-Openwrt-Router%2F</url>
    <content type="text"><![CDATA[I realize IP QoS(Quality of Service) in my Openwrt with iptables and tc(Traffic Control). Firstly , we should installs the related software packages.12opkg updateopkg install tc iptables If your firmware is trunk version, you have to install kmod-sched. this software has been installed in stable version. If openwrt lacks the software, “RTNETLINK answers: No such file or directory” will be present when you enter tc command. So:1opkg install kmod-sched After the above steps, let’s edit Qos shell scripts.12mkdir /etc/qosvi /etc/qos/start.sh Details of the start.sh are as follows:12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/shIDEV="br-lan"ODEV="tun0"UP="800kbit"DOWN="1200kbit"UPLOAD="80kbit"DOWNLOAD="120kbit"MUPLOAD="160kbit"MDOWNLOAD="160kbit"INET="192.168.254."IPS="240"IPE="249"tc qdisc del dev $ODEV root 2&gt;/dev/nulltc qdisc del dev $IDEV root 2&gt;/dev/nulltc qdisc add dev $ODEV root handle 10: htb default 256tc qdisc add dev $IDEV root handle 10: htb default 256tc class add dev $ODEV parent 10: classid 10:1 htb rate $UP ceil $UPtc class add dev $IDEV parent 10: classid 10:1 htb rate $DOWN ceil $DOWNi=$IPS;while [ $i -le $IPE ]dotc class add dev $ODEV parent 10:1 classid 10:2$i htb rate $UPLOAD ceil $MUPLOAD prio 1tc qdisc add dev $ODEV parent 10:2$i handle 100$i: pfifotc filter add dev $ODEV parent 10: protocol ip prio 100 handle 2$i fw classid 10:2$itc class add dev $IDEV parent 10:1 classid 10:2$i htb rate $DOWNLOAD ceil $MDOWNLOAD prio 1tc qdisc add dev $IDEV parent 10:2$i handle 100$i: pfifotc filter add dev $IDEV parent 10: protocol ip prio 100 handle 2$i fw classid 10:2$iiptables -t mangle -A PREROUTING -s $INET$i -j MARK --set-mark 2$iiptables -t mangle -A PREROUTING -s $INET$i -j RETURNiptables -t mangle -A POSTROUTING -d $INET$i -j MARK --set-mark 2$iiptables -t mangle -A POSTROUTING -d $INET$i -j RETURNi=`expr $i + 1`done Generate stop.sh.12345678910111213141516171819#!/bin/shINET="192.168.254."IPS="240"IPE="249"tc qdisc del dev $ODEV root 2&gt;/dev/nulltc qdisc del dev $IDEV root 2&gt;/dev/nullp=$IPS;while [ $p -le $IPE ]doiptables -t mangle -D PREROUTING -s $INET$p -j MARK --set-mark 2$piptables -t mangle -D PREROUTING -s $INET$p -j RETURNiptables -t mangle -D POSTROUTING -d $INET$p -j MARK --set-mark 2$piptables -t mangle -D POSTROUTING -d $INET$p -j RETURNp=`expr $p + 1`done 12chmod +x st*./start.sh]]></content>
      <categories>
        <category>OpenWRT</category>
      </categories>
      <tags>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to configure OpenVPN Client]]></title>
    <url>%2F2015%2F11%2F07%2FHow-to-configure-OpenVPN-Client%2F</url>
    <content type="text"><![CDATA[Generate client certifictes with OpenVPN serverBefore configuring client, I must generate some client files in the server.123cd /etc/openvpn/easy-rsasource vars./build-key client If you have some different devices, you can :123./build-key client1./build-key client2./build-key clientx After generating keys, we need to copy ca.crt , client.crt and client.key from server to client. Configure OpenVPN clientGenerate client configurationDetails are as follows:1234567891011121314clientdev tun # the same as serverproto udp #the same as serverremote vpn.server.hostname 7000resolv-retry infinitenobindpersist-keypersist-tunns-cert-type serververb 3ca ca.crtcert client.crtkey client.keycomp-lzo Ubuntu ClientSave the above configuration as “client.conf” in the path: /etc/openvpn, and Copy ca.crt , client.crt and client.key to /etc/openvpn/. Finally,1/etc/init.d/openvpn start Windows ClientDownload OpenVPN Client software via the link. There is an old version client in my github.After the client software installation, we can copy ca.crt , client.crt and client.key to installation_diretory/config. Start your OpenVPN, Right-click the OpenVPN icon on the taskbar and choose correct configuration to connect your server. Android deviceIf you use a portable device, you should modify your configuration as following the link.You can download the client software from Google Play. Also, you can download an old version client from my github.After installing the client, you can import configuration file to client and enjoy it. OpenWRT routeryou can copy your client.conf to /etc/openvpn. ou also must edit /etc/config/openvpn, the content is as follows:1234config openvpn custom_config option enable 1 option config /etc/openvpn/client.conf ...... start your openvpn:1/etc/init.d/openvpn start If you want to realize the self-starting function when your router is on:1/etc/init.d/openvpn enable]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>OpenWRT</tag>
        <tag>Linux</tag>
        <tag>OpenVPN</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The new Openwrt firmware support IPv6]]></title>
    <url>%2F2015%2F11%2F07%2FThe-new-Openwrt-firmware-support-IPv6%2F</url>
    <content type="text"><![CDATA[The old version firmware may have some bugs about IPv6 after my experiment.In order to support IPv6, I chose the newest firmware.After upgrading firmware, some configuration file must be modified.1vi /etc/config/dhcp Add or modify some contents as following:123456789101112131415config dhcp 'lan'option interface 'lan'option start '100'option limit '150'option leasetime '12h'option dhcpv6 'relay'option ra 'relay'option ndp 'relay'config dhcp 'wan6'option interface 'wan'option dhcpv6 'relay'option ra 'relay'option ndp 'relay'option master 1 Restart our router~~]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>OpenVPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to configure OpenVPN Server (Ubuntu 14.04LTS)]]></title>
    <url>%2F2015%2F11%2F06%2FHow-to-configure-OpenVPN-Server-Ubuntu-14-04LTS%2F</url>
    <content type="text"><![CDATA[Install Software123apt-get updateapt-get install openvpnapt-get install easy-rsa Generate Certificates12cp -r /usr/share/easy-rsa/ /etc/openvpn/cd /etc/openvpn/easy-rsa you can edit vars flie, I wanted 1024bit DH parms, so I changed KEY_SIZE from 2048 to 1024. Some options may be changed with yourself informations. For example, the KEY_EMAIL is modified by me with my private e-mail. Build ca.crt, dh1024.pem, server.key and server.crt12345source var./clean-all./build-ca./build-key-server server./buid-dh After finishing the above steps, ca.crt, dh1024.pem, server.key and server.crt had been generated in path /etc/openvpn/easy-rsa/keys. Edit OpenVPN server’s configuration file12cd /etc/openvpntouch server.conf Edit server.conf with gedit or vim, the .conf file content is as follows:1234567891011121314151617181920port 7000 #listening portproto udp #TCP or UDPdev tun #TAP or TUNca /etc/openvpn/easy-rsa/keys/ca.crtcert /etc/openvpn/easy-rsa/keys/server.crtkey /etc/openvpn/easy-rsa/keys/server.key # This file should be kept secretdh /etc/openvpn/easy-rsa/keys/dh1024.pemserver 10.8.0.0 255.255.255.0ifconfig-pool-persist ipp.txt #record of client &amp;lt;-&amp;gt; virtual IP address associationspush "redirect-gateway def1 bypass-dhcp"push "dhcp-option DNS 8.8.8.8"client-to-client #clients will see other clients, by default, clients will only see the serverkeepalive 10 120comp-lzopersist-keypersist-tunstatus openvpn-status.log # output a short log file showing current connectionslog openvpn.loglog-append openvpn.logverb 3 Start OpenVPN server and configure Forward123/etc/init.d/openvpn startecho 1 &gt; /proc/sys/net/ipv4/ip_forwardiptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE If your OpenVPN is running on the VPS:12iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j SNAT --to (venet0 ip)]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>OpenVPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Update OpenWRT Firmware by SSH or Uart]]></title>
    <url>%2F2015%2F11%2F05%2FHow-to-Update-OpenWRT-Firmware-by-SSH-or-Uart%2F</url>
    <content type="text"><![CDATA[If you want to have a diy router, I suggest you buy a openwrt router. Firstly, you can find “Table fo Hardware’. this is the main table of hardware, listing all devices that are suppprted by Openwrt. I had bought a GL.inet router, and its hardware was the same as the TL-WR720N, so I updated the router with WR720N’s firmware. There are some different versions firmares. Binary releases and historic releases are relatively stable, but it may not have some new features. Development Snapshots was the newest firmware. If you are not a developer, I suggest to use a stable firmware. Some softwares are incompatible across multiple releases. Development snapshots are updated fast, so we have to update the newest firmware when we want to install some sofrwares. However, I can lost some important configuration files if the firmware is updated. I can download my router’s firmware. there are usually 2 kind of firmware: sysupgrade and factory. Some configuration files (network, firewall, etc. ) will be reserved if the router is updated with sysupgrade firmware. All the configuration files will be cleared with factory firmware. Let’s update firmware:1wget https://downloads.openwrt.org/chaos_calmer/15.05/ar71xx/generic/xxx.bin If you download a sydupgrade version: 1sysupgrade -v xxx.bin Also, if you download factory version: 1mtd -r write xxx.bin firmware]]></content>
      <categories>
        <category>OpenWRT</category>
      </categories>
      <tags>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexapod robot]]></title>
    <url>%2F2012%2F10%2F30%2FHexapod-robot%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Robot</category>
      </categories>
      <tags>
        <tag>Hexapod robot</tag>
      </tags>
  </entry>
</search>
